<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ramedis Baseline Results Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .controls {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .controls input[type="file"] {
            margin: 10px;
        }
        .chart-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        .chart-wrapper {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        .chart-wrapper h3 {
            margin-top: 0;
            color: #333;
            text-align: center;
        }
        .download-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 12px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .download-btn:hover {
            background-color: #218838;
        }
        canvas {
            max-height: 600px;
        }
        .error {
            color: red;
            text-align: center;
            padding: 20px;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        #dataStatus {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
        }
        .drag-drop-zone {
            border: 2px dashed #007bff;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #f8f9fa;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .drag-drop-zone:hover {
            background-color: #e9ecef;
            border-color: #0056b3;
        }
        .drag-drop-zone.drag-over {
            background-color: #e3f2fd;
            border-color: #1976d2;
            border-style: solid;
        }
        .drag-drop-zone.file-loaded {
            background-color: #d4edda;
            border-color: #28a745;
            border-style: solid;
        }
        .drag-drop-zone h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .drag-drop-zone p {
            margin: 5px 0;
            color: #666;
            font-size: 14px;
        }
        .drag-drop-zone .file-info {
            color: #28a745;
            font-weight: bold;
            margin-top: 10px;
        }
        .drag-drop-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        @media (max-width: 768px) {
            .drag-drop-container {
                grid-template-columns: 1fr;
            }
        }
        #semanticFile, #severityFile {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Ramedis Baseline Experiment Results Visualization</h1>
        
        <div class="controls">
            <h3>Load JSON Data Files</h3>
            <div class="drag-drop-container">
                <div class="drag-drop-zone" id="semanticZone">
                    <h4>Drag and drop Semantic Evaluation JSON here</h4>
                    <p>or click to upload</p>
                    <input type="file" id="semanticFile" accept=".json">
                </div>
                <div class="drag-drop-zone" id="severityZone">
                    <h4>Drag and drop Severity Evaluation JSON here</h4>
                    <p>or click to upload</p>
                    <input type="file" id="severityFile" accept=".json">
                </div>
            </div>
            <button onclick="processFiles()">Generate Visualizations</button>
            <button onclick="downloadAllCharts()">Download All Charts as PNG</button>
            <div id="dataStatus"></div>
        </div>

        <div id="chartsContainer" class="chart-container"></div>
    </div>

    <script>
        let semanticData = null;
        let severityData = null;
        let charts = {};

        // File handling
        document.getElementById('semanticFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        semanticData = JSON.parse(e.target.result);
                        updateFileStatus('semanticZone', file.name, true);
                        updateStatus();
                    } catch (err) {
                        alert('Error parsing semantic JSON file');
                        updateFileStatus('semanticZone', '', false);
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('severityFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        severityData = JSON.parse(e.target.result);
                        updateFileStatus('severityZone', file.name, true);
                        updateStatus();
                    } catch (err) {
                        alert('Error parsing severity JSON file');
                        updateFileStatus('severityZone', '', false);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Drag and Drop functionality
        function setupDragAndDrop() {
            const semanticZone = document.getElementById('semanticZone');
            const severityZone = document.getElementById('severityZone');
            const semanticFile = document.getElementById('semanticFile');
            const severityFile = document.getElementById('severityFile');

            // Setup for semantic zone
            setupZone(semanticZone, semanticFile, (data, fileName) => {
                semanticData = data;
                updateFileStatus('semanticZone', fileName, true);
                updateStatus();
            });

            // Setup for severity zone
            setupZone(severityZone, severityFile, (data, fileName) => {
                severityData = data;
                updateFileStatus('severityZone', fileName, true);
                updateStatus();
            });
        }

        function setupZone(zone, fileInput, onSuccess) {
            // Click to upload
            zone.addEventListener('click', () => {
                fileInput.click();
            });

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('drag-over'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('drag-over'), false);
            });

            // Handle dropped files
            zone.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'application/json' || file.name.endsWith('.json')) {
                        handleFile(file, onSuccess);
                    } else {
                        alert('Please drop a valid JSON file');
                        updateFileStatus(zone.id, '', false);
                    }
                }
            }, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleFile(file, onSuccess) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    onSuccess(data, file.name);
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function updateFileStatus(zoneId, fileName, success) {
            const zone = document.getElementById(zoneId);
            const isSemanticZone = zoneId === 'semanticZone';
            
            if (success && fileName) {
                zone.classList.add('file-loaded');
                zone.innerHTML = `
                    <h4>${isSemanticZone ? 'Semantic' : 'Severity'} Evaluation JSON</h4>
                    <p>✅ File loaded successfully</p>
                    <div class="file-info">${fileName}</div>
                    <p style="font-size: 12px; margin-top: 10px;">Click to replace or drag another file</p>
                `;
            } else {
                zone.classList.remove('file-loaded');
                zone.innerHTML = `
                    <h4>Drag and drop ${isSemanticZone ? 'Semantic' : 'Severity'} Evaluation JSON here</h4>
                    <p>or click to upload</p>
                `;
            }
        }

        // Initialize drag and drop when DOM is loaded
        document.addEventListener('DOMContentLoaded', setupDragAndDrop);

        function updateStatus() {
            const status = document.getElementById('dataStatus');
            if (semanticData && severityData) {
                status.className = 'success';
                status.textContent = 'Both files loaded successfully. Click "Generate Visualizations" to proceed.';
            } else if (semanticData || severityData) {
                status.className = 'warning';
                status.textContent = `Loaded: ${semanticData ? 'Semantic' : ''} ${severityData ? 'Severity' : ''}. Please load both files.`;
            }
        }

        function processFiles() {
            if (!semanticData || !severityData) {
                alert('Please load both JSON files first');
                return;
            }
            
            const container = document.getElementById('chartsContainer');
            container.innerHTML = '';
            
            // Add statistics summary first
            createStatisticsSummary();
            
            // Generate only requested visualizations
            createSemanticBiasChart();
            createGDXvsDDXSeverityChart();
            createSemanticDistributionChart();
            createSeverityDistributionChart();
            createOptimistPessimistBalance();
        }
        
        function createStatisticsSummary() {
            // Calculate semantic statistics
            const semanticScores = semanticData.evaluations.map(e => e.best_match.score);
            const semanticMean = semanticScores.reduce((a, b) => a + b, 0) / semanticScores.length;
            const semanticStdDev = Math.sqrt(
                semanticScores.reduce((sq, n) => sq + Math.pow(n - semanticMean, 2), 0) / semanticScores.length
            );
            
            // Calculate severity statistics
            const severityScores = severityData.evaluations.map(e => e.final_score);
            const severityMean = severityScores.reduce((a, b) => a + b, 0) / severityScores.length;
            const severityStdDev = Math.sqrt(
                severityScores.reduce((sq, n) => sq + Math.pow(n - severityMean, 2), 0) / severityScores.length
            );
            
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'chart-wrapper';
            summaryDiv.innerHTML = `
                <h3>Statistical Summary</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 20px;">
                    <div>
                        <h4>Semantic Evaluation</h4>
                        <p><strong>Mean Score:</strong> ${semanticMean.toFixed(4)}</p>
                        <p><strong>Standard Deviation:</strong> ${semanticStdDev.toFixed(4)}</p>
                        <p><strong>Range:</strong> ${Math.min(...semanticScores).toFixed(4)} - ${Math.max(...semanticScores).toFixed(4)}</p>
                        <p style="font-size: 12px; color: #666;">
                            Semantic scores measure the similarity between ground truth diagnoses (GDX) 
                            and differential diagnoses (DDX) using BERT embeddings. Higher scores indicate 
                            better diagnostic accuracy.
                        </p>
                    </div>
                    <div>
                        <h4>Severity Evaluation</h4>
                        <p><strong>Mean Score:</strong> ${severityMean.toFixed(4)}</p>
                        <p><strong>Standard Deviation:</strong> ${severityStdDev.toFixed(4)}</p>
                        <p><strong>Range:</strong> ${Math.min(...severityScores).toFixed(4)} - ${Math.max(...severityScores).toFixed(4)}</p>
                        <p style="font-size: 12px; color: #666;">
                            Severity scores measure how well the DDX severities match the GDX severity, 
                            weighted by evaluator bias (optimist/pessimist). Scores range from 0 to 1, 
                            with higher values indicating better severity assessment.
                        </p>
                    </div>
                </div>
            `;
            document.getElementById('chartsContainer').appendChild(summaryDiv);
        }

        function createChartWrapper(id, title, description) {
            const wrapper = document.createElement('div');
            wrapper.className = 'chart-wrapper';
            wrapper.innerHTML = `
                <h3>${title}</h3>
                <button class="download-btn" onclick="downloadChart('${id}')">Download PNG</button>
                ${description ? `<p style="font-size: 12px; color: #666; margin: 10px 20px;">${description}</p>` : ''}
                <canvas id="${id}"></canvas>
            `;
            document.getElementById('chartsContainer').appendChild(wrapper);
            return document.getElementById(id).getContext('2d');
        }

        // Chart 1: Semantic Bias Evaluation
        function createSemanticBiasChart() {
            const ctx = createChartWrapper('semanticBiasChart', 
                'Gráfico de Evaluación Semántica por Sesgo',
                'Each point represents a case positioned by its severity final score (horizontal) and semantic similarity score (vertical). Cases with more optimist evaluators appear on the left, while those with more pessimist evaluators appear on the right. The Y-axis is centered to emphasize the bias distribution.');
            
            const scatterData = [];
            let maxScore = 0;
            
            // Process each case to get semantic scores and bias
            semanticData.evaluations.forEach((evaluation) => {
                const bestScore = evaluation.best_match.score;
                
                // Find corresponding severity evaluation
                const sevEval = severityData.evaluations.find(s => s.id === evaluation.case_id);
                if (!sevEval) return;
                
                // Use the final_score for position and n counts for direction
                const finalScore = sevEval.final_score;
                maxScore = Math.max(maxScore, finalScore);
                
                // Determine if optimist or pessimist based on counts
                if (sevEval.optimist.n > sevEval.pessimist.n) {
                    // More optimists - place on left (negative)
                    scatterData.push({
                        x: -finalScore,
                        y: bestScore,
                        type: 'optimist',
                        caseId: evaluation.case_id
                    });
                } else if (sevEval.pessimist.n > sevEval.optimist.n) {
                    // More pessimists - place on right (positive)
                    scatterData.push({
                        x: finalScore,
                        y: bestScore,
                        type: 'pessimist',
                        caseId: evaluation.case_id
                    });
                } else {
                    // Equal - place at center
                    scatterData.push({
                        x: 0,
                        y: bestScore,
                        type: 'neutral',
                        caseId: evaluation.case_id
                    });
                }
            });

            const optimistData = scatterData.filter(d => d.type === 'optimist');
            const pessimistData = scatterData.filter(d => d.type === 'pessimist');
            const neutralData = scatterData.filter(d => d.type === 'neutral');

            charts.semanticBiasChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Optimist Majority',
                        data: optimistData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5
                    }, {
                        label: 'Pessimist Majority',
                        data: pessimistData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5
                    }, {
                        label: 'Balanced',
                        data: neutralData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(128, 128, 128, 0.6)',
                        borderColor: 'rgba(128, 128, 128, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Evaluación Semántica por Sesgo de Evaluadores',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            position: 'bottom',
                            title: {
                                display: true,
                                text: '← Optimist Majority | Severity Score | Pessimist Majority →'
                            },
                            min: -maxScore * 1.1,
                            max: maxScore * 1.1,
                            grid: {
                                drawBorder: true,
                                borderWidth: 1,
                                borderColor: 'black',
                                lineWidth: function(context) {
                                    return context.tick.value === 0 ? 2 : 1;
                                },
                                color: function(context) {
                                    return context.tick.value === 0 ? 'black' : 'rgba(0,0,0,0.1)';
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return Math.abs(value).toFixed(3);
                                }
                            }
                        },
                        y: {
                            position: 'center',
                            title: {
                                display: true,
                                text: 'Semantic Level'
                            },
                            min: 0,
                            max: 1,
                            grid: {
                                drawBorder: true,
                                borderWidth: 1,
                                borderColor: 'black'
                            }
                        }
                    }
                }
            });
        }

        // Chart 2: GDX vs DDX Severity
        function createGDXvsDDXSeverityChart() {
            const ctx = createChartWrapper('gdxDdxSeverityChart', 
                'GDX vs DDX Severity Comparison',
                'Shows the relationship between ground truth (GDX) severity and the mean of differential diagnoses (DDX) severities. Blue points represent cases where DDX severities are lower (optimistic), red points where DDX severities are higher (pessimistic). The dashed line represents perfect match.');
            
            const optimistData = [];
            const pessimistData = [];
            const perfectMatch = [];
            
            severityData.evaluations.forEach(evaluation => {
                const gdxSeverity = parseInt(evaluation.gdx.severity.substring(1));
                
                // Calculate mean DDX severity for optimists and pessimists
                let optimistSevs = [];
                let pessimistSevs = [];
                
                evaluation.ddx_list.forEach(ddx => {
                    const ddxSeverity = parseInt(ddx.severity.substring(1));
                    
                    // Pessimists: DDX severity HIGHER than GDX (above the line)
                    if (ddxSeverity > gdxSeverity) {
                        pessimistSevs.push(ddxSeverity);
                    } 
                    // Optimists: DDX severity LOWER than GDX (below the line)
                    else if (ddxSeverity < gdxSeverity) {
                        optimistSevs.push(ddxSeverity);
                    }
                });
                
                // Add mean points for each case
                if (optimistSevs.length > 0) {
                    const meanOptimist = optimistSevs.reduce((a, b) => a + b, 0) / optimistSevs.length;
                    optimistData.push({x: gdxSeverity, y: meanOptimist});
                }
                
                if (pessimistSevs.length > 0) {
                    const meanPessimist = pessimistSevs.reduce((a, b) => a + b, 0) / pessimistSevs.length;
                    pessimistData.push({x: gdxSeverity, y: meanPessimist});
                }
            });
            
            // Create perfect match line
            for (let i = 3; i <= 10; i++) {
                perfectMatch.push({x: i, y: i});
            }

            charts.gdxDdxSeverityChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Perfect Match',
                        data: perfectMatch,
                        type: 'line',
                        borderColor: 'rgba(0, 0, 0, 0.8)',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 2,
                        order: 0
                    }, {
                        label: 'Mean Optimist DDX (Below Line)',
                        data: optimistData,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 1
                    }, {
                        label: 'Mean Pessimist DDX (Above Line)',
                        data: pessimistData,
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Mean DDX Severity vs GDX Severity by Evaluator Type',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'GDX Severity'
                            },
                            min: 3,
                            max: 10,
                            ticks: {
                                stepSize: 1
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Mean DDX Severity'
                            },
                            min: 3,
                            max: 10,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Chart 3: Semantic Score Distribution
        function createSemanticDistributionChart() {
            const ctx = createChartWrapper('semanticDistChart', 
                'Semantic Similarity Score Distribution',
                'Histogram showing the frequency distribution of all semantic similarity scores between GDX and DDX pairs. Scores range from 0 (no similarity) to 1 (perfect match). This includes all DDX candidates across all cases.');
            
            const allScores = [];
            const bestScores = [];
            
            semanticData.evaluations.forEach(evaluation => {
                bestScores.push(evaluation.best_match.score);
                Object.values(evaluation.ddx_semantic_scores).forEach(scores => {
                    allScores.push(...scores);
                });
            });
            
            // Create histogram bins
            const bins = [];
            const binLabels = [];
            for (let i = 0; i <= 1; i += 0.1) {
                bins.push(0);
                binLabels.push(i.toFixed(1));
            }
            
            allScores.forEach(score => {
                const binIndex = Math.min(Math.floor(score * 10), 10);
                bins[binIndex]++;
            });

            charts.semanticDistChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'All Semantic Scores',
                        data: bins,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Distribution of All Semantic Similarity Scores',
                            font: {
                                size: 16
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Semantic Score'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        }
                    }
                }
            });
        }

        // Chart 4: Severity Distribution
        function createSeverityDistributionChart() {
            const ctx = createChartWrapper('severityDistChart', 
                'Severity Level Distribution',
                'Compares the distribution of severity levels between GDX (ground truth) and DDX (differential diagnoses). GDX counts are multiplied by 5 to compensate for the 1:5 ratio. Severity levels range from S3 (least severe) to S10 (most severe).');
            
            const gdxSeverities = {};
            const ddxSeverities = {};
            
            // Initialize severity counts
            for (let i = 3; i <= 10; i++) {
                gdxSeverities[`S${i}`] = 0;
                ddxSeverities[`S${i}`] = 0;
            }
            
            severityData.evaluations.forEach(evaluation => {
                gdxSeverities[evaluation.gdx.severity]++;
                evaluation.ddx_list.forEach(ddx => {
                    ddxSeverities[ddx.severity]++;
                });
            });
            
            // Multiply GDX severities by 5 as requested
            const gdxData = Object.values(gdxSeverities).map(count => count * 5);

            charts.severityDistChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(gdxSeverities),
                    datasets: [{
                        label: 'GDX Severities (×5)',
                        data: gdxData,
                        backgroundColor: 'rgba(255, 159, 64, 0.6)',
                        borderColor: 'rgba(255, 159, 64, 1)',
                        borderWidth: 1
                    }, {
                        label: 'DDX Severities',
                        data: Object.values(ddxSeverities),
                        backgroundColor: 'rgba(153, 102, 255, 0.6)',
                        borderColor: 'rgba(153, 102, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Distribution of Severity Levels (GDX vs DDX)',
                            font: {
                                size: 16
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Severity Level'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        }
                    }
                }
            });
        }

        // Chart 5: Optimist vs Pessimist Balance
        function createOptimistPessimistBalance() {
            const ctx = createChartWrapper('optimistPessimistChart', 
                'Optimist vs Pessimist Evaluator Balance',
                'Doughnut chart showing the overall distribution of evaluator types across all cases. Optimists tend to assign lower severity scores than the ground truth, while pessimists assign higher severity scores.');
            
            let totalOptimist = 0;
            let totalPessimist = 0;
            
            severityData.evaluations.forEach(evaluation => {
                totalOptimist += evaluation.optimist.n;
                totalPessimist += evaluation.pessimist.n;
            });

            charts.optimistPessimistChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Optimist Evaluators', 'Pessimist Evaluators'],
                    datasets: [{
                        data: [totalOptimist, totalPessimist],
                        backgroundColor: [
                            'rgba(54, 162, 235, 0.8)',
                            'rgba(255, 99, 132, 0.8)'
                        ],
                        borderColor: [
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 99, 132, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Overall Distribution of Evaluator Types',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'bottom'
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                let sum = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                let percentage = (value * 100 / sum).toFixed(1) + "%";
                                return percentage;
                            },
                            color: '#fff',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        // Download functions
        function downloadChart(chartId) {
            const canvas = document.getElementById(chartId);
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `${chartId}.png`;
            link.href = url;
            link.click();
        }

        function downloadAllCharts() {
            Object.keys(charts).forEach(chartId => {
                setTimeout(() => downloadChart(chartId), 100);
            });
        }
    </script>
</body>
</html>
