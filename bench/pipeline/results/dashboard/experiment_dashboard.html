<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experiment Dashboard - DxGPT Diagnostic Benchmarking</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.0/dist/simple-statistics.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #050505;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #141414;
            --bg-card: #1a1a1a;
            --border-primary: #1f1f1f;
            --border-secondary: #2a2a2a;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --text-tertiary: #6b7280;
            --accent-primary: #dc2626;
            --accent-hover: #ef4444;
            --success: #34d399;
            --warning: #fbbf24;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Layout */
        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            overflow-y: auto;
            flex-shrink: 0;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-primary);
        }

        .sidebar-header h2 {
            font-size: 1.125rem;
            font-weight: 300;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: var(--text-primary);
        }

        .experiments-list {
            padding: 16px;
        }

        .experiment-item {
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .experiment-item:hover {
            border-color: var(--accent-primary);
            background: #1f1f1f;
        }

        .experiment-item.selected {
            border-color: var(--accent-primary);
            background: #1f1f1f;
        }

        .experiment-checkbox {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .experiment-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }

        .experiment-info {
            flex: 1;
        }

        .experiment-name {
            font-weight: 400;
            font-size: 0.95rem;
            margin-bottom: 4px;
        }

        .experiment-timestamp {
            font-size: 0.75rem;
            color: var(--text-tertiary);
        }

        .experiment-scores {
            display: flex;
            gap: 16px;
            margin-top: 8px;
            font-size: 0.75rem;
        }

        .score-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .score-label {
            color: var(--text-tertiary);
        }

        .score-value {
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .main-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 24px 32px;
        }

        .main-header h1 {
            font-size: 2rem;
            font-weight: 200;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .subtitle {
            color: var(--text-tertiary);
            font-size: 0.875rem;
            letter-spacing: 0.02em;
        }

        /* View Tabs */
        .view-tabs {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            padding: 0 32px;
        }

        .view-tab {
            padding: 16px 24px;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 400;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            transition: all 0.3s ease;
            position: relative;
        }

        .view-tab:hover {
            color: var(--text-primary);
        }

        .view-tab.active {
            color: var(--text-primary);
        }

        .view-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-primary);
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 32px;
        }

        /* Comparison View */
        .comparison-view {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .chart-container {
            flex: 1;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 32px;
            position: relative;
        }

        /* Detail View */
        .detail-view {
            display: none;
        }

        .detail-controls {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .grid-selector {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .grid-selector label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .grid-selector select {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 0.875rem;
            cursor: pointer;
        }

        .grid-container {
            display: grid;
            gap: 24px;
            grid-template-columns: 1fr;
        }

        .grid-cell {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 24px;
            min-height: 400px;
            height: 500px;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .cell-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-shrink: 0;
        }

        .cell-controls select {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 0.75rem;
            cursor: pointer;
            flex: 1;
        }

        /* Floating Panel */
        .floating-panel {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-secondary);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 12px;
            z-index: 1000;
        }

        .panel-btn {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .panel-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        /* JSON Explorer Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .json-viewer {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .close-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px;
        }

        /* Loading State */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-tertiary);
            font-size: 1.125rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                transform: translateX(-100%);
                z-index: 1000;
            }

            .sidebar.open {
                transform: translateX(0);
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }

        /* Grid Layouts */
        .grid-1x1 { grid-template-columns: 1fr; }
        .grid-1x2 { grid-template-columns: repeat(2, 1fr); }
        .grid-2x2 { 
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }

        /* Chart Defaults */
        canvas {
            max-width: 100% !important;
            max-height: 100% !important;
        }
        
        .chart-wrapper {
            position: relative;
            height: 100%;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>Experiments</h2>
            </div>
            <div class="experiments-list" id="experimentsList">
                <div class="loading">Loading experiments...</div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <h1>DxGPT Diagnostic Benchmarking Dashboard</h1>
                <p class="subtitle">Unified analysis platform for experiment comparison and detailed evaluation</p>
            </header>

            <!-- View Tabs -->
            <div class="view-tabs">
                <button class="view-tab active" data-view="comparison">Comparison</button>
                <button class="view-tab" data-view="detail">Detailed Analysis</button>
            </div>

            <!-- Content Area -->
            <div class="content-area">
                <!-- Comparison View -->
                <div class="comparison-view" id="comparisonView">
                    <div class="chart-container">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                </div>

                <!-- Detail View -->
                <div class="detail-view" id="detailView">
                    <div class="detail-controls">
                        <div class="grid-selector">
                            <label>Grid Layout:</label>
                            <select id="gridLayout">
                                <option value="1x1">1x1</option>
                                <option value="1x2">1x2</option>
                                <option value="2x2">2x2</option>
                            </select>
                        </div>
                    </div>
                    <div class="grid-container grid-1x1" id="gridContainer"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Floating Control Panel -->
    <div class="floating-panel">
        <button class="panel-btn" onclick="exportCurrentView()">Export View</button>
        <button class="panel-btn" onclick="openJsonExplorer()">JSON Explorer</button>
        <button class="panel-btn" onclick="saveToExperiment()">Save Plots</button>
    </div>

    <!-- JSON Explorer Modal -->
    <div class="modal" id="jsonModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>JSON Explorer</h3>
                <button class="close-btn" onclick="closeJsonExplorer()">&times;</button>
            </div>
            <div class="modal-body">
                <select id="jsonFileSelector" style="width: 100%; margin-bottom: 16px; background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border-secondary); padding: 8px; border-radius: 6px;">
                    <option value="">Select experiment and file...</option>
                </select>
                <div class="json-viewer" id="jsonViewer"></div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let experiments = new Map();
        let selectedExperiments = new Set();
        let comparisonChart = null;
        let detailCharts = new Map();
        let currentView = 'comparison';

        // Chart.js defaults
        Chart.defaults.color = '#ffffff';
        Chart.defaults.borderColor = '#374151';
        Chart.defaults.backgroundColor = '#1f2937';

        // Initialize dashboard
        async function initDashboard() {
            console.log('Initializing dashboard...');
            await loadExperiments();
            setupEventListeners();
            updateViews();
        }

        // Load experiments from filesystem
        async function loadExperiments() {
            try {
                // Dynamically discover experiment folders
                const experimentPaths = await discoverExperiments();

                for (const path of experimentPaths) {
                    try {
                        const experiment = await loadExperiment(path);
                        if (experiment) {
                            experiments.set(path, experiment);
                        }
                    } catch (err) {
                        console.warn(`Failed to load experiment ${path}:`, err);
                    }
                }

                renderExperimentsList();
            } catch (err) {
                console.error('Failed to load experiments:', err);
                document.getElementById('experimentsList').innerHTML = '<div class="error">Failed to load experiments</div>';
            }
        }

        // Discover experiment folders
        async function discoverExperiments() {
            const knownExperiments = [];
            
            // First try to use the API endpoint if available
            try {
                const apiResponse = await fetch('/api/experiments');
                if (apiResponse.ok) {
                    const experimentList = await apiResponse.json();
                    console.log('Loaded experiments from API:', experimentList);
                    
                    // Verify each experiment exists
                    for (const exp of experimentList) {
                        try {
                            const response = await fetch(`../${exp}/summary.json`, { method: 'HEAD' });
                            if (response.ok) {
                                knownExperiments.push(exp);
                            }
                        } catch (err) {
                            console.warn(`Experiment ${exp} not accessible`);
                        }
                    }
                    
                    if (knownExperiments.length > 0) {
                        return knownExperiments;
                    }
                }
            } catch (err) {
                console.warn('Could not load experiments from API, trying fallback methods');
            }
            
            // Try to fetch directory listing (would need server support)
            try {
                const response = await fetch('../');
                if (response.ok) {
                    const text = await response.text();
                    // Parse directory listing HTML (Apache/Nginx style)
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/html');
                    const links = doc.querySelectorAll('a');
                    
                    links.forEach(link => {
                        const href = link.getAttribute('href');
                        if (href && href.startsWith('experiment_') && href.endsWith('/')) {
                            knownExperiments.push(href.slice(0, -1));
                        }
                    });
                }
            } catch (err) {
                console.warn('Could not fetch directory listing, using fallback method');
            }
            
            // If no experiments found, try known experiments by checking if they exist
            if (knownExperiments.length === 0) {
                // List of potential experiments to check
                const potentialExperiments = [
                    'experiment_gpt_4o_20250609011432',
                    'experiment_jonsnow_20250610123831',
                    'experiment_medgemma_20250610153330',
                    'experiment_openbio_20250610154901',
                    'experiment_sakura_20250610150849'
                ];
                
                // Check each potential experiment
                for (const exp of potentialExperiments) {
                    try {
                        const response = await fetch(`../${exp}/summary.json`);
                        if (response.ok) {
                            knownExperiments.push(exp);
                            console.log(`Found experiment: ${exp}`);
                        }
                    } catch (err) {
                        console.warn(`Could not access ${exp}:`, err);
                    }
                }
            }
            
            console.log('Discovered experiments:', knownExperiments);
            return knownExperiments;
        }

        // Load individual experiment
        async function loadExperiment(path) {
            const basePath = `../${path}`;
            
            try {
                const experiment = {
                    id: path,
                    name: extractModelName(path),
                    timestamp: extractTimestamp(path),
                    path: basePath,
                    summary: null,
                    semantic: null,
                    severity: null
                };

                // Try to load the JSON files
                try {
                    const summaryResponse = await fetch(`${basePath}/summary.json`);
                    if (summaryResponse.ok) {
                        experiment.summary = await summaryResponse.json();
                    }
                } catch (err) {
                    console.warn(`Could not load summary.json for ${path}`);
                }

                try {
                    const semanticResponse = await fetch(`${basePath}/semantic_evaluation.json`);
                    if (semanticResponse.ok) {
                        experiment.semantic = await semanticResponse.json();
                    }
                } catch (err) {
                    console.warn(`Could not load semantic_evaluation.json for ${path}`);
                }

                try {
                    const severityResponse = await fetch(`${basePath}/severity_evaluation.json`);
                    if (severityResponse.ok) {
                        experiment.severity = await severityResponse.json();
                    }
                } catch (err) {
                    console.warn(`Could not load severity_evaluation.json for ${path}`);
                }

                return experiment;
            } catch (err) {
                console.error(`Error loading experiment ${path}:`, err);
                return null;
            }
        }

        // Extract model name from path
        function extractModelName(path) {
            const parts = path.split('_');
            if (parts.length >= 2) {
                return parts.slice(1, -1).join(' ').replace(/(\w)(\w*)/g, (_, first, rest) => 
                    first.toUpperCase() + rest.toLowerCase()
                );
            }
            return path;
        }

        // Extract timestamp from path
        function extractTimestamp(path) {
            const match = path.match(/(\d{14})$/);
            if (match) {
                const ts = match[1];
                const year = ts.substring(0, 4);
                const month = ts.substring(4, 6);
                const day = ts.substring(6, 8);
                const hour = ts.substring(8, 10);
                const minute = ts.substring(10, 12);
                return `${year}-${month}-${day} ${hour}:${minute}`;
            }
            return '';
        }

        // Render experiments list
        function renderExperimentsList() {
            const container = document.getElementById('experimentsList');
            container.innerHTML = '';

            if (experiments.size === 0) {
                container.innerHTML = '<div class="loading">No experiments found</div>';
                return;
            }

            experiments.forEach((exp, id) => {
                const semanticScore = exp.summary?.semantic_evaluation?.mean_score || '-';
                const severityScore = exp.summary?.severity_evaluation?.mean_score || '-';
                
                const item = document.createElement('div');
                item.className = 'experiment-item';
                item.innerHTML = `
                    <div class="experiment-checkbox">
                        <input type="checkbox" id="exp-${id}" data-experiment="${id}" />
                        <div class="experiment-info">
                            <div class="experiment-name">${exp.name}</div>
                            <div class="experiment-timestamp">${exp.timestamp}</div>
                            <div class="experiment-scores">
                                <div class="score-item">
                                    <span class="score-label">Semantic:</span>
                                    <span class="score-value">${typeof semanticScore === 'number' ? semanticScore.toFixed(4) : semanticScore}</span>
                                </div>
                                <div class="score-item">
                                    <span class="score-label">Severity:</span>
                                    <span class="score-value">${typeof severityScore === 'number' ? severityScore.toFixed(4) : severityScore}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                const checkbox = item.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        selectedExperiments.add(id);
                        item.classList.add('selected');
                    } else {
                        selectedExperiments.delete(id);
                        item.classList.remove('selected');
                    }
                    updateViews();
                });

                container.appendChild(item);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // View tabs
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    currentView = e.target.dataset.view;
                    document.getElementById('comparisonView').style.display = 
                        currentView === 'comparison' ? 'flex' : 'none';
                    document.getElementById('detailView').style.display = 
                        currentView === 'detail' ? 'block' : 'none';
                    
                    updateViews();
                });
            });

            // Grid layout selector
            document.getElementById('gridLayout').addEventListener('change', (e) => {
                const container = document.getElementById('gridContainer');
                container.className = `grid-container grid-${e.target.value}`;
                updateDetailView();
            });
        }

        // Update views based on selection
        function updateViews() {
            if (currentView === 'comparison') {
                updateComparisonView();
            } else {
                updateDetailView();
            }
        }

        // Update comparison view
        function updateComparisonView() {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            
            if (comparisonChart) {
                comparisonChart.destroy();
            }

            const datasets = [];
            const colors = ['#dc2626', '#ef4444', '#f87171', '#fca5a5', '#fecaca', '#fee2e2'];
            const markers = ['circle', 'triangle', 'rect', 'star', 'cross', 'crossRot'];
            let colorIndex = 0;

            selectedExperiments.forEach(expId => {
                const exp = experiments.get(expId);
                if (exp && exp.summary) {
                    const semanticScore = exp.summary.semantic_evaluation?.mean_score || 0;
                    const severityScore = exp.summary.severity_evaluation?.mean_score || 0;
                    
                    datasets.push({
                        label: exp.name,
                        data: [{
                            x: severityScore,
                            y: semanticScore
                        }],
                        backgroundColor: colors[colorIndex % colors.length],
                        borderColor: colors[colorIndex % colors.length],
                        borderWidth: 2,
                        pointStyle: markers[colorIndex % markers.length],
                        pointRadius: 10,
                        pointHoverRadius: 12
                    });
                    colorIndex++;
                }
            });

            comparisonChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#ffffff',
                                font: { size: 14 },
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            backgroundColor: '#262626',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#404040',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: Semantic=${context.parsed.y.toFixed(4)}, Severity=${context.parsed.x.toFixed(4)}`;
                                }
                            }
                        },
                        zoom: {
                            pan: { enabled: true, mode: 'xy' },
                            zoom: {
                                wheel: { enabled: true },
                                mode: 'xy'
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Severity Score',
                                color: '#ffffff',
                                font: { size: 16 }
                            },
                            grid: { color: '#404040' },
                            ticks: { color: '#ffffff' },
                            min: 0,
                            max: 1,
                            reverse: true
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Semantic Score',
                                color: '#ffffff',
                                font: { size: 16 }
                            },
                            grid: { color: '#404040' },
                            ticks: { color: '#ffffff' },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        // Update detail view
        function updateDetailView() {
            const container = document.getElementById('gridContainer');
            const layout = document.getElementById('gridLayout').value;
            
            // Clear existing grid
            container.innerHTML = '';
            detailCharts.clear();

            // Determine grid size
            let cellCount = 1;
            if (layout === '1x2') cellCount = 2;
            else if (layout === '2x2') cellCount = 4;

            // Create grid cells
            for (let i = 0; i < cellCount; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.innerHTML = `
                    <div class="cell-controls">
                        <select class="experiment-selector" data-cell="${i}">
                            <option value="">Select experiment...</option>
                            ${Array.from(selectedExperiments).map(expId => {
                                const exp = experiments.get(expId);
                                return `<option value="${expId}">${exp.name}</option>`;
                            }).join('')}
                        </select>
                        <select class="chart-selector" data-cell="${i}" disabled>
                            <option value="">Select chart...</option>
                        </select>
                    </div>
                    <div style="flex: 1; position: relative; overflow: hidden;">
                        <canvas id="detailChart${i}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
                    </div>
                `;

                // Add event listeners
                const expSelector = cell.querySelector('.experiment-selector');
                const chartSelector = cell.querySelector('.chart-selector');
                
                expSelector.addEventListener('change', (e) => {
                    if (e.target.value) {
                        chartSelector.disabled = false;
                        populateChartOptions(chartSelector, e.target.value);
                    } else {
                        chartSelector.disabled = true;
                        chartSelector.innerHTML = '<option value="">Select chart...</option>';
                    }
                });

                chartSelector.addEventListener('change', (e) => {
                    if (e.target.value && expSelector.value) {
                        renderDetailChart(i, expSelector.value, e.target.value);
                    }
                });

                container.appendChild(cell);
            }
        }

        // Populate chart options based on experiment
        function populateChartOptions(selector, expId) {
            // Chart options grouped by category - matching original visualize_run_evals.html
            const chartGroups = {
                'Summary': [
                    { value: 'stats-summary', label: 'Statistical Summary' }
                ],
                'Combined': [
                    { value: 'semantic-bias', label: 'Combined Bias Evaluation' }
                ],
                'Semantic Analysis': [
                    { value: 'semantic-histogram', label: 'Score Distribution with KDE' },
                    { value: 'ridge-plot', label: 'Ridge Plot by Severity' }
                ],
                'Severity Analysis': [
                    { value: 'gdx-ddx-severity', label: 'GDX vs DDX Severity' },
                    { value: 'severity-levels', label: 'Severity Levels Distribution' },
                    { value: 'optimist-pessimist', label: 'Optimist vs Pessimist Balance' }
                ]
            };

            selector.innerHTML = '<option value="">Select chart...</option>';
            
            Object.entries(chartGroups).forEach(([group, charts]) => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = group;
                
                charts.forEach(chart => {
                    const option = document.createElement('option');
                    option.value = chart.value;
                    option.textContent = chart.label;
                    optgroup.appendChild(option);
                });
                
                selector.appendChild(optgroup);
            });
        }

        // Simple KDE implementation
        function calculateKDE(data, bandwidth, min, max, steps = 100) {
            if (!data || data.length === 0) return [];
            
            const kde = [];
            const stepSize = (max - min) / steps;
            
            for (let i = 0; i <= steps; i++) {
                const x = min + i * stepSize;
                let sum = 0;
                
                data.forEach(d => {
                    const diff = (x - d) / bandwidth;
                    // Gaussian kernel
                    sum += Math.exp(-0.5 * diff * diff) / Math.sqrt(2 * Math.PI);
                });
                
                kde.push({
                    x: x,
                    y: sum / (data.length * bandwidth)
                });
            }
            
            return kde;
        }

        // Render detail chart
        function renderDetailChart(cellIndex, expId, chartType) {
            const canvas = document.getElementById(`detailChart${cellIndex}`);
            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (detailCharts.has(cellIndex)) {
                detailCharts.get(cellIndex).destroy();
            }

            // Get experiment data
            const exp = experiments.get(expId);
            if (!exp) {
                chart = createPlaceholderChart(ctx, 'No data available');
                detailCharts.set(cellIndex, chart);
                return;
            }

            // For demo purposes, create charts with simulated data
            // In production, load actual semantic and severity JSON data
            let chart;
            
            switch (chartType) {
                case 'stats-summary':
                    chart = createStatsSummary(ctx, exp);
                    break;
                case 'semantic-bias':
                    chart = createSemanticBiasChart(ctx, exp);
                    break;
                case 'semantic-histogram':
                    chart = createSemanticHistogram(ctx, exp);
                    break;
                case 'ridge-plot':
                    chart = createRidgePlot(ctx, exp);
                    break;
                case 'gdx-ddx-severity':
                    chart = createGDXvsDDXChart(ctx, exp);
                    break;
                case 'severity-levels':
                    chart = createSeverityLevelsChart(ctx, exp);
                    break;
                case 'optimist-pessimist':
                    chart = createOptimistPessimistChart(ctx, exp);
                    break;
                default:
                    chart = createPlaceholderChart(ctx, chartType);
            }

            detailCharts.set(cellIndex, chart);
        }

        // Create stats summary
        function createStatsSummary(ctx, exp) {
            // Simulated data - in production, use actual data from exp.semantic and exp.severity
            const semanticScores = Array.from({length: 50}, () => 0.5 + Math.random() * 0.5);
            const severityScores = Array.from({length: 50}, () => Math.random() * 0.5);
            
            const semanticMean = semanticScores.reduce((a, b) => a + b, 0) / semanticScores.length;
            const severityMean = severityScores.reduce((a, b) => a + b, 0) / severityScores.length;
            
            // Create a text-based chart showing statistics
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Semantic Mean', 'Severity Mean'],
                    datasets: [{
                        label: 'Mean Scores',
                        data: [semanticMean, severityMean],
                        backgroundColor: ['rgba(99, 102, 241, 0.6)', 'rgba(239, 68, 68, 0.6)'],
                        borderColor: ['rgba(99, 102, 241, 1)', 'rgba(239, 68, 68, 1)'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1
                        }
                    }
                }
            });
        }

        // Create semantic histogram with KDE
        function createSemanticHistogram(ctx, exp) {
            // Simulated semantic scores - in production, extract from exp.semantic
            const allSemanticScores = Array.from({length: 100}, () => 0.3 + Math.random() * 0.7);
            
            // Create histogram bins
            const bins = 25;
            const binWidth = 1.0 / bins;
            const histogram = new Array(bins).fill(0);
            
            allSemanticScores.forEach(score => {
                const binIndex = Math.min(Math.floor(score / binWidth), bins - 1);
                histogram[binIndex]++;
            });
            
            // Create bin labels
            const binLabels = [];
            const histogramData = [];
            for (let i = 0; i < bins; i++) {
                const binStart = i * binWidth;
                const binEnd = (i + 1) * binWidth;
                binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
                histogramData.push(histogram[i]);
            }
            
            // Calculate KDE
            const kde = calculateKDE(allSemanticScores, 0.05, 0, 1, bins);
            const maxHistCount = Math.max(...histogram);
            const maxKDE = Math.max(...kde.map(d => d.y));
            
            // Scale KDE to match histogram height
            const kdeScaled = kde.map((point, i) => ({
                x: binLabels[Math.floor(i * bins / kde.length)] || binLabels[binLabels.length - 1],
                y: (point.y / maxKDE) * maxHistCount * 1.1
            }));

            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Semantic Score Count',
                        data: histogramData,
                        backgroundColor: 'rgba(99, 102, 241, 0.6)',
                        borderColor: 'rgba(99, 102, 241, 1)',
                        borderWidth: 1,
                        order: 2,
                        barPercentage: 0.95,
                        categoryPercentage: 1.0
                    }, {
                        label: 'KDE Curve',
                        data: kdeScaled,
                        type: 'line',
                        borderColor: 'rgba(245, 158, 11, 0.9)',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.4,
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round',
                        order: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Semantic Similarity Score Range'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count / Density'
                            }
                        }
                    }
                }
            });
        }

        // Create semantic bias chart
        function createSemanticBiasChart(ctx, exp) {
            const scatterData = [];
            let maxScore = 0;
            
            // Use real data if available
            if (exp.semantic && exp.severity) {
                const semanticEvals = exp.semantic.evaluations || [];
                const severityEvals = exp.severity.evaluations || [];
                
                // Create a map for quick lookup
                const severityMap = new Map();
                severityEvals.forEach(sev => {
                    severityMap.set(sev.id, sev);
                });
                
                // Process each case
                semanticEvals.forEach((semEval, idx) => {
                    const caseId = semEval.case_id || idx + 1;
                    const severityEval = severityMap.get(caseId);
                    
                    if (severityEval) {
                        // Get the best semantic score
                        const semanticScore = semEval.best_match?.score || 0;
                        const finalScore = severityEval.final_score || 0;
                        maxScore = Math.max(maxScore, finalScore);
                        
                        const optimistN = severityEval.optimist?.n || 0;
                        const pessimistN = severityEval.pessimist?.n || 0;
                        
                        if (optimistN > pessimistN) {
                            scatterData.push({
                                x: -finalScore,
                                y: semanticScore,
                                type: 'optimist',
                                caseId: caseId
                            });
                        } else if (pessimistN > optimistN) {
                            scatterData.push({
                                x: finalScore,
                                y: semanticScore,
                                type: 'pessimist',
                                caseId: caseId
                            });
                        } else {
                            scatterData.push({
                                x: 0,
                                y: semanticScore,
                                type: 'neutral',
                                caseId: caseId
                            });
                        }
                    }
                });
            }
            
            // If no real data, use simulated data
            if (scatterData.length === 0) {
                for (let i = 0; i < 100; i++) {
                    const semanticScore = 0.3 + Math.random() * 0.7;
                    const finalScore = Math.random() * 0.5;
                    maxScore = Math.max(maxScore, finalScore);
                    
                    const optimistN = Math.floor(Math.random() * 6);
                    const pessimistN = Math.floor(Math.random() * 6);
                    
                    if (optimistN > pessimistN) {
                        scatterData.push({
                            x: -finalScore,
                            y: semanticScore,
                            type: 'optimist',
                            caseId: i + 1
                        });
                    } else if (pessimistN > optimistN) {
                        scatterData.push({
                            x: finalScore,
                            y: semanticScore,
                            type: 'pessimist',
                            caseId: i + 1
                        });
                    } else {
                        scatterData.push({
                            x: 0,
                            y: semanticScore,
                            type: 'neutral',
                            caseId: i + 1
                        });
                    }
                }
            }

            const optimistData = scatterData.filter(d => d.type === 'optimist');
            const pessimistData = scatterData.filter(d => d.type === 'pessimist');
            const neutralData = scatterData.filter(d => d.type === 'neutral');
            
            // Calculate mean points
            const allMeanX = scatterData.length > 0 ? scatterData.reduce((sum, d) => sum + d.x, 0) / scatterData.length : 0;
            const allMeanY = scatterData.length > 0 ? scatterData.reduce((sum, d) => sum + d.y, 0) / scatterData.length : 0;
            
            const optimistMeanX = optimistData.length > 0 ? 
                optimistData.reduce((sum, d) => sum + d.x, 0) / optimistData.length : 0;
            const optimistMeanY = optimistData.length > 0 ? 
                optimistData.reduce((sum, d) => sum + d.y, 0) / optimistData.length : 0;
            
            const pessimistMeanX = pessimistData.length > 0 ? 
                pessimistData.reduce((sum, d) => sum + d.x, 0) / pessimistData.length : 0;
            const pessimistMeanY = pessimistData.length > 0 ? 
                pessimistData.reduce((sum, d) => sum + d.y, 0) / pessimistData.length : 0;

            const neutralMeanX = neutralData.length > 0 ? 
                neutralData.reduce((sum, d) => sum + d.x, 0) / neutralData.length : 0;
            const neutralMeanY = neutralData.length > 0 ? 
                neutralData.reduce((sum, d) => sum + d.y, 0) / neutralData.length : 0;

            // Create horizontal histogram data
            const horizontalBins = 40;
            const horizontalBinWidth = (maxScore * 2.4) / horizontalBins;
            const horizontalHistogram = new Array(horizontalBins).fill(0);
            
            scatterData.forEach(d => {
                const binIndex = Math.floor((d.x + maxScore * 1.2) / horizontalBinWidth);
                if (binIndex >= 0 && binIndex < horizontalBins) {
                    horizontalHistogram[binIndex]++;
                }
            });
            
            // Create histogram bars as rectangles at bottom
            const histogramData = [];
            const maxHistCount = Math.max(...horizontalHistogram);
            const histScale = 0.18; // Height scale for histogram
            
            for (let i = 0; i < horizontalBins; i++) {
                if (horizontalHistogram[i] > 0) {
                    const x = -maxScore * 1.2 + (i + 0.5) * horizontalBinWidth;
                    const height = (horizontalHistogram[i] / maxHistCount) * histScale;
                    
                    // Create a dense set of points to form a bar
                    const barWidth = horizontalBinWidth * 0.9;
                    const pointsPerBar = 25;
                    
                    for (let px = 0; px < pointsPerBar; px++) {
                        const xOffset = (px / pointsPerBar - 0.5) * barWidth;
                        for (let py = 0; py <= 12; py++) {
                            histogramData.push({
                                x: x + xOffset,
                                y: -0.05 + (height * py / 12)
                            });
                        }
                    }
                }
            }

            return new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Distribution',
                        data: histogramData,
                        backgroundColor: 'rgba(156, 163, 175, 0.3)',
                        borderColor: 'transparent',
                        pointRadius: 2,
                        pointHoverRadius: 2,
                        showLine: false,
                        order: 10
                    }, {
                        label: 'Optimist Majority',
                        data: optimistData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(59, 130, 246, 0.48)',
                        borderColor: 'rgba(59, 130, 246, 0.8)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 3
                    }, {
                        label: 'Pessimist Majority',
                        data: pessimistData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(239, 68, 68, 0.48)',
                        borderColor: 'rgba(239, 68, 68, 0.8)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 3
                    }, {
                        label: 'Balanced',
                        data: neutralData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(128, 128, 128, 0.48)',
                        borderColor: 'rgba(128, 128, 128, 0.8)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 3
                    }, {
                        label: 'Overall Mean',
                        data: [{x: allMeanX, y: allMeanY}],
                        backgroundColor: 'rgba(255, 235, 59, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }, {
                        label: 'Optimist Mean',
                        data: optimistData.length > 0 ? [{x: optimistMeanX, y: optimistMeanY}] : [],
                        backgroundColor: 'rgba(54, 162, 235, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }, {
                        label: 'Pessimist Mean',
                        data: pessimistData.length > 0 ? [{x: pessimistMeanX, y: pessimistMeanY}] : [],
                        backgroundColor: 'rgba(255, 99, 132, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }, {
                        label: 'Neutral Mean',
                        data: neutralData.length > 0 ? [{x: neutralMeanX, y: neutralMeanY}] : [],
                        backgroundColor: 'rgba(156, 163, 175, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 30,
                            bottom: 30,
                            left: 30,
                            right: 30
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: {
                                    size: 12
                                },
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 20,
                                usePointStyle: true
                            },
                            align: 'center'
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            position: 'bottom',
                            title: {
                                display: true,
                                text: '← Optimist Majority | Severity Score | Pessimist Majority →',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    return Math.abs(value).toFixed(3);
                                }
                            },
                            min: -maxScore * 1.2,
                            max: maxScore * 1.2,
                            grid: {
                                drawBorder: true,
                                borderWidth: 1,
                                borderColor: 'black',
                                lineWidth: function(context) {
                                    return context.tick.value === 0 ? 2 : 1;
                                },
                                color: function(context) {
                                    return context.tick.value === 0 ? '#374151' : '#1f2937';
                                }
                            }
                        },
                        y: {
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Semantic Level',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            min: -0.05,
                            max: 1.0,
                            grid: {
                                drawBorder: true,
                                borderWidth: 1,
                                borderColor: '#374151',
                                color: '#1f2937'
                            }
                        }
                    }
                }
            });
        }

        // Create ridge plot
        function createRidgePlot(ctx, exp) {
            // Simulated data grouped by GDX severity
            const scoresByGDXSeverity = {};
            for (let i = 3; i <= 10; i++) {
                scoresByGDXSeverity[`S${i}`] = [];
            }
            
            // Simulate semantic scores grouped by severity
            for (let caseId = 1; caseId <= 50; caseId++) {
                const gdxSeverity = `S${Math.floor(Math.random() * 8) + 3}`;
                // Generate multiple semantic scores per case
                for (let j = 0; j < 5; j++) {
                    scoresByGDXSeverity[gdxSeverity].push(0.3 + Math.random() * 0.7);
                }
            }
            
            // Calculate KDE for each severity level
            const ridgeData = [];
            const severityLevels = Object.keys(scoresByGDXSeverity).reverse(); // Top to bottom
            
            severityLevels.forEach((severity, idx) => {
                const scores = scoresByGDXSeverity[severity];
                if (scores.length > 0) {
                    const kde = calculateKDE(scores, 0.05, 0, 1, 100);
                    const maxDensity = Math.max(...kde.map(d => d.y));
                    
                    // Normalize and offset for ridge effect
                    const normalizedKDE = kde.map(point => ({
                        x: point.x,
                        y: (point.y / maxDensity) * 0.8 + idx
                    }));
                    
                    ridgeData.push({
                        severity: severity,
                        kde: normalizedKDE,
                        baseline: idx,
                        color: `hsl(${260 - idx * 20}, 70%, 60%)` // Gradient from purple to orange
                    });
                }
            });
            
            // Custom plugin for ridge plot
            const ridgePlugin = {
                id: 'ridge',
                beforeDraw: (chart) => {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y;
                    
                    ridgeData.forEach((ridge, idx) => {
                        // Draw filled area
                        ctx.save();
                        ctx.beginPath();
                        
                        // Start from baseline
                        ctx.moveTo(
                            xScale.getPixelForValue(0),
                            yScale.getPixelForValue(ridge.baseline)
                        );
                        
                        // Draw KDE curve
                        ridge.kde.forEach(point => {
                            const x = xScale.getPixelForValue(point.x);
                            const y = yScale.getPixelForValue(point.y);
                            ctx.lineTo(x, y);
                        });
                        
                        // Close path at baseline
                        ctx.lineTo(
                            xScale.getPixelForValue(1),
                            yScale.getPixelForValue(ridge.baseline)
                        );
                        ctx.closePath();
                        
                        // Fill with gradient
                        const gradient = ctx.createLinearGradient(
                            0, yScale.getPixelForValue(ridge.baseline + 0.8),
                            0, yScale.getPixelForValue(ridge.baseline)
                        );
                        gradient.addColorStop(0, ridge.color);
                        gradient.addColorStop(1, ridge.color.replace('60%', '30%'));
                        
                        ctx.fillStyle = gradient;
                        ctx.globalAlpha = 0.7;
                        ctx.fill();
                        
                        // Draw outline
                        ctx.strokeStyle = ridge.color;
                        ctx.globalAlpha = 1;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Add severity label
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 12px Inter';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            ridge.severity,
                            chartArea.left - 10,
                            yScale.getPixelForValue(ridge.baseline + 0.4)
                        );
                        
                        ctx.restore();
                    });
                }
            };
            
            return new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: [] // Empty dataset for Chart.js structure
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 50,
                            right: 20
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Semantic Score',
                                color: '#ffffff'
                            },
                            min: 0,
                            max: 1,
                            ticks: {
                                color: '#9ca3af'
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        },
                        y: {
                            type: 'linear',
                            min: -0.5,
                            max: severityLevels.length - 0.5,
                            display: false
                        }
                    }
                },
                plugins: [ridgePlugin]
            });
        }

        // Create GDX vs DDX severity chart
        function createGDXvsDDXChart(ctx, exp) {
            const optimistData = [];
            const pessimistData = [];
            const perfectMatch = [];
            
            // Group data by GDX severity for boxplots
            const gdxGroups = {};
            const boxplotData = [];
            const boxplotFillData = [];
            
            for (let i = 0; i <= 10; i++) {
                perfectMatch.push({x: i, y: i});
                gdxGroups[i] = {
                    optimist: [],
                    pessimist: [],
                    all: []
                };
            }
            
            // Simulate evaluation data
            for (let caseId = 1; caseId <= 50; caseId++) {
                const gdxSeverity = Math.floor(Math.random() * 8) + 3; // S3 to S10
                
                // Simulate DDX severities
                for (let j = 0; j < 5; j++) {
                    const ddxSeverity = gdxSeverity + (Math.random() - 0.5) * 4;
                    const clampedDDX = Math.max(0, Math.min(10, ddxSeverity));
                    
                    gdxGroups[gdxSeverity].all.push(clampedDDX);
                    
                    if (clampedDDX < gdxSeverity) {
                        gdxGroups[gdxSeverity].optimist.push(clampedDDX);
                    } else if (clampedDDX > gdxSeverity) {
                        gdxGroups[gdxSeverity].pessimist.push(clampedDDX);
                    }
                }
            }
            
            // Create mean points and boxplot data
            Object.keys(gdxGroups).forEach(gdxSev => {
                const gdxSeverity = parseInt(gdxSev);
                const optimistValues = gdxGroups[gdxSeverity].optimist;
                const pessimistValues = gdxGroups[gdxSeverity].pessimist;
                
                // Add mean points
                if (optimistValues.length > 0) {
                    const meanOptimist = optimistValues.reduce((a, b) => a + b, 0) / optimistValues.length;
                    optimistData.push({x: gdxSeverity, y: meanOptimist});
                }
                
                if (pessimistValues.length > 0) {
                    const meanPessimist = pessimistValues.reduce((a, b) => a + b, 0) / pessimistValues.length;
                    pessimistData.push({x: gdxSeverity, y: meanPessimist});
                }
                
                // Create boxplot data
                if (optimistValues.length > 0) {
                    const sorted = optimistValues.sort((a, b) => a - b);
                    const q1 = sorted[Math.floor(sorted.length * 0.25)];
                    const median = sorted[Math.floor(sorted.length * 0.5)];
                    const q3 = sorted[Math.floor(sorted.length * 0.75)];
                    const min = sorted[0];
                    const max = sorted[sorted.length - 1];
                    
                    const boxLeft = gdxSeverity - 0.35;
                    const boxRight = gdxSeverity - 0.15;
                    const centerX = (boxLeft + boxRight) / 2;
                    
                    boxplotFillData.push({
                        type: 'optimist',
                        boxLeft: boxLeft,
                        boxRight: boxRight,
                        q1: q1,
                        q3: q3,
                        median: median
                    });
                    
                    // Box outline
                    boxplotData.push({x: boxLeft, y: q1, x2: boxRight, y2: q1, type: 'optimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q3, x2: boxRight, y2: q3, type: 'optimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q1, x2: boxLeft, y2: q3, type: 'optimist', lineType: 'vertical'});
                    boxplotData.push({x: boxRight, y: q1, x2: boxRight, y2: q3, type: 'optimist', lineType: 'vertical'});
                    boxplotData.push({x: boxLeft, y: median, x2: boxRight, y2: median, type: 'optimist', lineType: 'median'});
                    boxplotData.push({x: centerX, y: min, x2: centerX, y2: q1, type: 'optimist', lineType: 'whisker'});
                    boxplotData.push({x: centerX, y: q3, x2: centerX, y2: max, type: 'optimist', lineType: 'whisker'});
                }
                
                if (pessimistValues.length > 0) {
                    const sorted = pessimistValues.sort((a, b) => a - b);
                    const q1 = sorted[Math.floor(sorted.length * 0.25)];
                    const median = sorted[Math.floor(sorted.length * 0.5)];
                    const q3 = sorted[Math.floor(sorted.length * 0.75)];
                    const min = sorted[0];
                    const max = sorted[sorted.length - 1];
                    
                    const boxLeft = gdxSeverity + 0.15;
                    const boxRight = gdxSeverity + 0.35;
                    const centerX = (boxLeft + boxRight) / 2;
                    
                    boxplotFillData.push({
                        type: 'pessimist',
                        boxLeft: boxLeft,
                        boxRight: boxRight,
                        q1: q1,
                        q3: q3,
                        median: median
                    });
                    
                    // Box outline
                    boxplotData.push({x: boxLeft, y: q1, x2: boxRight, y2: q1, type: 'pessimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q3, x2: boxRight, y2: q3, type: 'pessimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q1, x2: boxLeft, y2: q3, type: 'pessimist', lineType: 'vertical'});
                    boxplotData.push({x: boxRight, y: q1, x2: boxRight, y2: q3, type: 'pessimist', lineType: 'vertical'});
                    boxplotData.push({x: boxLeft, y: median, x2: boxRight, y2: median, type: 'pessimist', lineType: 'median'});
                    boxplotData.push({x: centerX, y: min, x2: centerX, y2: q1, type: 'pessimist', lineType: 'whisker'});
                    boxplotData.push({x: centerX, y: q3, x2: centerX, y2: max, type: 'pessimist', lineType: 'whisker'});
                }
            });

            // Create bottom histogram for GDX severity distribution
            const gdxSeverityHist = {};
            for (let i = 0; i <= 10; i++) {
                gdxSeverityHist[i] = 0;
            }
            
            // Count GDX severities (simulated)
            for (let i = 0; i < 50; i++) {
                const gdxSev = Math.floor(Math.random() * 8) + 3;
                gdxSeverityHist[gdxSev]++;
            }
            
            // Create histogram bars as points at bottom
            const bottomHistogramData = [];
            const maxGdxCount = Math.max(...Object.values(gdxSeverityHist));
            const histScale = 0.6;
            
            for (let severity = 0; severity <= 10; severity++) {
                const count = gdxSeverityHist[severity];
                if (count > 0) {
                    const height = (count / maxGdxCount) * histScale;
                    const barWidth = 0.6;
                    const pointsPerBar = 15;
                    
                    for (let px = 0; px < pointsPerBar; px++) {
                        const xOffset = (px / pointsPerBar - 0.5) * barWidth;
                        for (let py = 0; py <= 8; py++) {
                            bottomHistogramData.push({
                                x: severity + xOffset,
                                y: -0.3 + (height * py / 8)
                            });
                        }
                    }
                }
            }

            // Custom plugin for drawing boxplots
            const boxplotPlugin = {
                id: 'minimalBoxplots',
                afterDatasetsDraw: function(chart) {
                    const ctx = chart.ctx;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y;
                    
                    // First draw the filled areas
                    boxplotFillData.forEach(box => {
                        const leftPx = xScale.getPixelForValue(box.boxLeft);
                        const rightPx = xScale.getPixelForValue(box.boxRight);
                        const q1Px = yScale.getPixelForValue(box.q1);
                        const q3Px = yScale.getPixelForValue(box.q3);
                        const medianPx = yScale.getPixelForValue(box.median);
                        
                        ctx.save();
                        
                        const isOptimist = box.type === 'optimist';
                        const baseColor = isOptimist ? [59, 130, 246] : [239, 68, 68];
                        
                        // Upper box fill (Q3 to median)
                        ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.12)`;
                        ctx.fillRect(leftPx, q3Px, rightPx - leftPx, medianPx - q3Px);
                        
                        // Lower box fill (median to Q1)
                        ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.18)`;
                        ctx.fillRect(leftPx, medianPx, rightPx - leftPx, q1Px - medianPx);
                        
                        ctx.restore();
                    });
                    
                    // Then draw the line elements
                    const groupedLines = {};
                    boxplotData.forEach(line => {
                        if (!line.x2) return;
                        const key = `${Math.round(line.x * 10)}:${line.type}`;
                        if (!groupedLines[key]) {
                            groupedLines[key] = {
                                type: line.type,
                                lines: []
                            };
                        }
                        groupedLines[key].lines.push(line);
                    });
                    
                    Object.values(groupedLines).forEach(group => {
                        const lines = group.lines;
                        const isOptimist = group.type === 'optimist';
                        const baseColor = isOptimist ? [59, 130, 246] : [239, 68, 68];
                        
                        ctx.save();
                        
                        lines.forEach(line => {
                            const x1Px = xScale.getPixelForValue(line.x);
                            const y1Px = yScale.getPixelForValue(line.y);
                            const x2Px = xScale.getPixelForValue(line.x2);
                            const y2Px = yScale.getPixelForValue(line.y2);
                            
                            ctx.beginPath();
                            ctx.moveTo(x1Px, y1Px);
                            ctx.lineTo(x2Px, y2Px);
                            
                            if (line.lineType === 'median') {
                                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.9)`;
                                ctx.lineWidth = 2;
                            } else if (line.lineType === 'whisker') {
                                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.5)`;
                                ctx.lineWidth = 1;
                            } else {
                                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.7)`;
                                ctx.lineWidth = 1;
                            }
                            
                            ctx.stroke();
                        });
                        
                        ctx.restore();
                    });
                }
            };

            return new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'GDX Severity Distribution',
                        data: bottomHistogramData,
                        backgroundColor: 'rgba(156, 163, 175, 0.25)',
                        borderColor: 'transparent',
                        pointRadius: 1.5,
                        pointHoverRadius: 1.5,
                        showLine: false,
                        order: 10
                    }, {
                        label: 'Perfect Match',
                        data: perfectMatch,
                        type: 'line',
                        borderColor: 'rgba(156, 163, 175, 0.8)',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 2,
                        order: 0
                    }, {
                        label: 'Mean Optimist DDX (Below Line)',
                        data: optimistData,
                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 1
                    }, {
                        label: 'Mean Pessimist DDX (Above Line)',
                        data: pessimistData,
                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: { size: 12 },
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'GDX Severity',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                stepSize: 1
                            },
                            grid: {
                                color: '#1f2937'
                            },
                            min: 0,
                            max: 10
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Mean DDX Severity',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                stepSize: 1
                            },
                            grid: {
                                color: '#1f2937'
                            },
                            min: -0.4,
                            max: 10
                        }
                    }
                },
                plugins: [boxplotPlugin]
            });
        }

        // Create severity levels chart
        function createSeverityLevelsChart(ctx, exp) {
            // Count severity levels for GDX and DDX
            const gdxCounts = {};
            const ddxCounts = {};
            const gdxRawData = [];
            const ddxRawData = [];
            
            // Initialize counts
            for (let i = 3; i <= 10; i++) {
                gdxCounts[`S${i}`] = 0;
                ddxCounts[`S${i}`] = 0;
            }
            
            // Simulate count data
            for (let caseId = 1; caseId <= 50; caseId++) {
                const gdxSeverity = Math.floor(Math.random() * 8) + 3;
                gdxCounts[`S${gdxSeverity}`]++;
                gdxRawData.push(gdxSeverity);
                
                // Simulate 5 DDX per case
                for (let j = 0; j < 5; j++) {
                    const ddxSeverity = Math.max(3, Math.min(10, gdxSeverity + Math.floor((Math.random() - 0.5) * 4)));
                    ddxCounts[`S${ddxSeverity}`]++;
                    ddxRawData.push(ddxSeverity);
                }
            }
            
            // Prepare data for chart
            const severityLabels = [];
            const gdxData = [];
            const ddxData = [];
            
            for (let i = 3; i <= 10; i++) {
                const severity = `S${i}`;
                severityLabels.push(severity);
                
                // Multiply GDX by 5 to account for 1:5 ratio
                const gdxCount = gdxCounts[severity] * 5;
                const ddxCount = ddxCounts[severity];
                
                gdxData.push(gdxCount);
                ddxData.push(ddxCount);
            }
            
            // Calculate KDE for smooth curves
            const gdxKDE = calculateKDE(gdxRawData, 0.5, 3, 10, 200);
            const ddxKDE = calculateKDE(ddxRawData, 0.5, 3, 10, 200);
            
            // Scale KDE to match histogram heights
            const maxGdx = Math.max(...gdxData.filter(v => v > 0), 1);
            const maxDdx = Math.max(...ddxData.filter(v => v > 0), 1);
            const maxKdeGdx = gdxKDE.length > 0 ? Math.max(...gdxKDE.map(d => d.y)) : 1;
            const maxKdeDdx = ddxKDE.length > 0 ? Math.max(...ddxKDE.map(d => d.y)) : 1;
            
            // Create KDE data points that align with severity labels
            const gdxKdeScaled = [];
            const ddxKdeScaled = [];
            
            for (let i = 0; i < severityLabels.length; i++) {
                const severityNum = i + 3;
                
                // Find KDE values around this severity level
                const gdxKdePoint = gdxKDE.find(d => Math.abs(d.x - severityNum) < 0.25);
                const ddxKdePoint = ddxKDE.find(d => Math.abs(d.x - severityNum) < 0.25);
                
                if (gdxKdePoint) {
                    gdxKdeScaled.push({
                        x: severityLabels[i],
                        y: (gdxKdePoint.y / maxKdeGdx) * maxGdx * 1.2
                    });
                }
                
                if (ddxKdePoint) {
                    ddxKdeScaled.push({
                        x: severityLabels[i], 
                        y: (ddxKdePoint.y / maxKdeDdx) * maxDdx * 1.2
                    });
                }
            }

            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: severityLabels,
                    datasets: [{
                        label: 'GDX (×5 for visualization)',
                        data: gdxData,
                        backgroundColor: 'rgba(16, 185, 129, 0.6)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1,
                        order: 3,
                        barPercentage: 0.8,
                        categoryPercentage: 0.9
                    }, {
                        label: 'DDX',
                        data: ddxData,
                        backgroundColor: 'rgba(249, 115, 22, 0.6)',
                        borderColor: 'rgba(249, 115, 22, 1)',
                        borderWidth: 1,
                        order: 3,
                        barPercentage: 0.8,
                        categoryPercentage: 0.9
                    }, {
                        label: 'GDX KDE Curve',
                        data: gdxKdeScaled,
                        type: 'line',
                        borderColor: 'rgba(16, 185, 129, 0.8)',
                        backgroundColor: 'rgba(16, 185, 129, 0.05)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.4,
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round',
                        cubicInterpolationMode: 'monotone',
                        order: 1
                    }, {
                        label: 'DDX KDE Curve', 
                        data: ddxKdeScaled,
                        type: 'line',
                        borderColor: 'rgba(249, 115, 22, 0.8)',
                        backgroundColor: 'rgba(249, 115, 22, 0.05)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.4,
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round',
                        cubicInterpolationMode: 'monotone',
                        order: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: { size: 12 },
                                padding: 20,
                                usePointStyle: true
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Severity Level',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        }
                    }
                }
            });
        }

        // Create optimist vs pessimist chart
        function createOptimistPessimistChart(ctx, exp) {
            // Count cases by score comparison
            let optimistCases = 0;
            let pessimistCases = 0;
            
            // Count by n value for each type
            const optimistByN = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
            const pessimistByN = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
            
            // Simulate evaluation data
            for (let caseId = 1; caseId <= 50; caseId++) {
                const optimistScore = Math.random();
                const pessimistScore = Math.random();
                
                if (optimistScore > pessimistScore) {
                    optimistCases++;
                    // Add to n distribution for optimists
                    const n = Math.floor(Math.random() * 5) + 1;
                    optimistByN[n]++;
                } else if (pessimistScore > optimistScore) {
                    pessimistCases++;
                    // Add to n distribution for pessimists
                    const n = Math.floor(Math.random() * 5) + 1;
                    pessimistByN[n]++;
                }
            }

            // Create plugin to draw center text
            const centerTextPlugin = {
                id: 'centerText',
                beforeDraw: function(chart) {
                    const ctx = chart.ctx;
                    const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                    const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = '300 24px Inter';
                    ctx.fillStyle = '#e5e7eb';
                    ctx.fillText(optimistCases + ' | ' + pessimistCases, centerX, centerY - 10);
                    ctx.font = '300 12px Inter';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText('Optimist | Pessimist', centerX, centerY + 15);
                    ctx.restore();
                }
            };

            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [
                        'Opt n=1', 'Opt n=2', 'Opt n=3', 'Opt n=4', 'Opt n=5',
                        'Pes n=1', 'Pes n=2', 'Pes n=3', 'Pes n=4', 'Pes n=5'
                    ],
                    datasets: [{
                        data: [
                            optimistByN[1], optimistByN[2], optimistByN[3], optimistByN[4], optimistByN[5],
                            pessimistByN[1], pessimistByN[2], pessimistByN[3], pessimistByN[4], pessimistByN[5]
                        ],
                        backgroundColor: [
                            // Optimist shades (blue gradient)
                            'rgba(59, 130, 246, 0.9)',
                            'rgba(59, 130, 246, 0.75)',
                            'rgba(59, 130, 246, 0.6)',
                            'rgba(59, 130, 246, 0.45)',
                            'rgba(59, 130, 246, 0.3)',
                            // Pessimist shades (red gradient)
                            'rgba(239, 68, 68, 0.9)',
                            'rgba(239, 68, 68, 0.75)',
                            'rgba(239, 68, 68, 0.6)',
                            'rgba(239, 68, 68, 0.45)',
                            'rgba(239, 68, 68, 0.3)'
                        ],
                        borderColor: '#1f2937',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                font: { size: 12 },
                                padding: 15,
                                boxWidth: 15,
                                boxHeight: 15,
                                usePointStyle: true
                            }
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                if (value === 0) return '';
                                return value;
                            },
                            color: '#ffffff',
                            font: {
                                size: 11,
                                weight: '300'
                            },
                            textAlign: 'center',
                            display: function(context) {
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    return label + ': ' + value + ' cases';
                                }
                            }
                        }
                    }
                },
                plugins: [centerTextPlugin]
            });
        }

        // Create placeholder chart
        function createPlaceholderChart(ctx, type) {
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['A', 'B', 'C', 'D', 'E'],
                    datasets: [{
                        label: type,
                        data: [0.2, 0.4, 0.6, 0.8, 0.5],
                        borderColor: 'rgba(220, 38, 38, 1)',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        // Export current view
        function exportCurrentView() {
            if (currentView === 'comparison' && comparisonChart) {
                const canvas = document.getElementById('comparisonChart');
                exportCanvas(canvas, 'comparison_view');
            } else if (currentView === 'detail') {
                // Export all visible charts in grid
                const layout = document.getElementById('gridLayout').value;
                if (layout === '1x1' && detailCharts.has(0)) {
                    const canvas = document.getElementById('detailChart0');
                    exportCanvas(canvas, 'detail_view');
                } else {
                    // For multiple charts, combine them
                    combineAndExportCharts();
                }
            }
        }

        // Export single canvas
        function exportCanvas(canvas, filename) {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}_${new Date().toISOString().slice(0, 10)}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Combine and export multiple charts
        function combineAndExportCharts() {
            const layout = document.getElementById('gridLayout').value;
            const canvases = [];
            
            detailCharts.forEach((_, index) => {
                const canvas = document.getElementById(`detailChart${index}`);
                if (canvas) canvases.push(canvas);
            });

            if (canvases.length === 0) return;

            // Create combined canvas
            const combinedCanvas = document.createElement('canvas');
            const ctx = combinedCanvas.getContext('2d');
            
            if (layout === '1x2') {
                combinedCanvas.width = canvases[0].width * 2;
                combinedCanvas.height = canvases[0].height;
                canvases.forEach((canvas, i) => {
                    ctx.drawImage(canvas, i * canvas.width, 0);
                });
            } else if (layout === '2x2') {
                combinedCanvas.width = canvases[0].width * 2;
                combinedCanvas.height = canvases[0].height * 2;
                canvases.forEach((canvas, i) => {
                    const x = (i % 2) * canvas.width;
                    const y = Math.floor(i / 2) * canvas.height;
                    ctx.drawImage(canvas, x, y);
                });
            }

            exportCanvas(combinedCanvas, 'grid_view');
        }

        // Save plots to experiment folder
        function saveToExperiment() {
            // In production, this would save to the server
            // For now, show a message
            if (selectedExperiments.size === 0) {
                alert('Please select an experiment first');
                return;
            }

            const expId = Array.from(selectedExperiments)[0];
            const exp = experiments.get(expId);
            alert(`Plots would be saved to: ${exp.path}/plots/`);
        }

        // Open JSON explorer
        function openJsonExplorer() {
            const modal = document.getElementById('jsonModal');
            const selector = document.getElementById('jsonFileSelector');
            
            // Populate file options
            selector.innerHTML = '<option value="">Select experiment and file...</option>';
            
            experiments.forEach((exp, expId) => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = exp.name;
                
                ['summary.json', 'semantic_evaluation.json', 'severity_evaluation.json'].forEach(file => {
                    const option = document.createElement('option');
                    option.value = `${expId}|${file}`;
                    option.textContent = file;
                    optgroup.appendChild(option);
                });
                
                selector.appendChild(optgroup);
            });

            selector.addEventListener('change', (e) => {
                if (e.target.value) {
                    const [expId, file] = e.target.value.split('|');
                    loadAndDisplayJson(expId, file);
                }
            });

            modal.style.display = 'flex';
        }

        // Load and display JSON
        async function loadAndDisplayJson(expId, filename) {
            const viewer = document.getElementById('jsonViewer');
            const exp = experiments.get(expId);
            
            if (!exp) {
                viewer.textContent = 'Experiment not found';
                return;
            }

            let data = null;
            
            // Get the data based on filename
            switch (filename) {
                case 'summary.json':
                    data = exp.summary;
                    break;
                case 'semantic_evaluation.json':
                    data = exp.semantic;
                    break;
                case 'severity_evaluation.json':
                    data = exp.severity;
                    break;
            }

            if (data) {
                viewer.textContent = JSON.stringify(data, null, 2);
            } else {
                // Try to fetch the file if not already loaded
                try {
                    const response = await fetch(`${exp.path}/${filename}`);
                    if (response.ok) {
                        const jsonData = await response.json();
                        viewer.textContent = JSON.stringify(jsonData, null, 2);
                    } else {
                        viewer.textContent = `Could not load ${filename}`;
                    }
                } catch (err) {
                    viewer.textContent = `Error loading ${filename}: ${err.message}`;
                }
            }
        }

        // Close JSON explorer
        function closeJsonExplorer() {
            document.getElementById('jsonModal').style.display = 'none';
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', initDashboard);
    </script>

    <!-- Data loader fixes -->
    <script src="data_loader_fix.js"></script>
    <script src="patch_dashboard.js"></script>

</body>
</html>