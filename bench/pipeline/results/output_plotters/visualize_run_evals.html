<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ramedis Baseline Results Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.0/dist/simple-statistics.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 0;
            background: #050505;
            color: #e5e7eb;
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        h1 {
            font-size: 2rem;
            font-weight: 200;
            letter-spacing: 0.05em;
            margin: 0 0 20px 0;
            color: #e5e7eb;
            text-transform: uppercase;
        }
        
        .subtitle {
            color: #6b7280;
            font-size: 0.875rem;
            margin-bottom: 40px;
            letter-spacing: 0.02em;
        }
        
        .controls {
            background: linear-gradient(135deg, #0a0a0a 0%, #141414 100%);
            border: 1px solid #1f1f1f;
            border-radius: 12px;
            padding: 28px;
            margin-bottom: 40px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }
        
        .controls h3 {
            margin: 0 0 20px 0;
            color: #d1d5db;
            font-weight: 400;
            font-size: 1rem;
            letter-spacing: 0.025em;
            text-align: center;
        }
        
        .file-upload-section {
            background: #111111;
            border: 1px solid #1f1f1f;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .instructions-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .instructions-badge {
            background: linear-gradient(135deg, #1f1f1f 0%, #2a2a2a 100%);
            color: #9ca3af;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 400;
            letter-spacing: 0.05em;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }
        
        .action-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .primary-button {
            background: linear-gradient(135deg, #1c1c1c 0%, #2a2a2a 100%);
            color: #e5e7eb;
            border: 1px solid rgba(239, 68, 68, 0.3);
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.025em;
        }
        
        .primary-button:hover {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border-color: rgba(239, 68, 68, 0.5);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.15);
        }
        
        .secondary-button {
            background: #141414;
            color: #9ca3af;
            border: 1px solid #2a2a2a;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.025em;
        }
        
        .secondary-button:hover {
            background: #1c1c1c;
            border-color: #374151;
            color: #d1d5db;
        }
        
        .tabs {
            display: flex;
            gap: 1px;
            background: transparent;
            padding: 0;
            border-radius: 0;
            margin-bottom: 40px;
            overflow-x: auto;
            border-bottom: 1px solid #1f2937;
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-radius: 0;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }
        
        .tab:hover {
            background: #1f2937;
            color: #ffffff;
        }
        
        .tab.active {
            background: transparent;
            color: #e5e7eb;
            border-color: transparent;
        }
        
        .chart-container {
            display: none;
        }
        
        .chart-container.active {
            display: block;
        }
        
        .chart-wrapper {
            background: #0f0f0f;
            border: 1px solid #1f2937;
            padding: 30px;
            border-radius: 8px;
            position: relative;
            min-height: 600px;
        }
        
        .chart-wrapper h3 {
            margin: 0 0 10px 0;
            color: #e5e7eb;
            font-size: 1.25rem;
            font-weight: 300;
            letter-spacing: 0.02em;
        }
        
        .chart-wrapper p {
            color: #9ca3af;
            font-size: 0.875rem;
            margin-bottom: 25px;
            line-height: 1.5;
            font-weight: 300;
        }
        
        .download-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            padding: 6px 12px;
            font-size: 11px;
            background: transparent;
            color: #6b7280;
            border: 1px solid #374151;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .download-btn:hover {
            background: #111111;
            color: #9ca3af;
            border-color: #4b5563;
        }
        
        canvas {
            max-height: 500px;
        }
        
        #dataStatus {
            margin: 20px 0;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
            font-weight: 300;
        }
        
        .success {
            background-color: #064e3b;
            color: #34d399;
            border: 1px solid #065f46;
        }
        
        .warning {
            background-color: #713f12;
            color: #fbbf24;
            border: 1px solid #92400e;
        }
        
        .drag-drop-zone {
            border: 1px dashed #2a2a2a;
            border-radius: 8px;
            padding: 24px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #0a0a0a 0%, #141414 100%);
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        .drag-drop-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.03) 0%, rgba(185, 28, 28, 0.03) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .drag-drop-zone:hover {
            border-color: rgba(239, 68, 68, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .drag-drop-zone:hover::before {
            opacity: 1;
        }
        
        .drag-drop-zone.drag-over {
            border-color: rgba(239, 68, 68, 0.6);
            border-style: solid;
            background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        }
        
        .drag-drop-zone.file-loaded {
            border-color: rgba(239, 68, 68, 0.5);
            border-style: solid;
            background: linear-gradient(135deg, #141414 0%, #1a1a1a 100%);
        }
        
        .drag-drop-zone h4 {
            margin: 0 0 10px 0;
            color: #e5e7eb;
            font-weight: 300;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .drag-drop-zone p {
            margin: 5px 0;
            color: #6b7280;
            font-size: 14px;
        }
        
        .drag-drop-zone .file-info {
            color: #34d399;
            font-weight: 500;
            margin-top: 10px;
        }
        
        .drag-drop-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            padding: 0;
        }
        
        .stat-card {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            padding: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: #374151;
        }
        
        .stat-card h4 {
            color: #e5e7eb;
            font-size: 1rem;
            font-weight: 300;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 200;
            color: #e5e7eb;
            margin: 10px 0;
        }
        
        .stat-label {
            color: #6b7280;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin: 15px 0;
        }
        
        @media (max-width: 768px) {
            .drag-drop-container {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: 1fr;
            }
            .tabs {
                flex-wrap: wrap;
            }
        }
        
        #semanticFile, #severityFile {
            display: none;
        }
        
        /* Premium styling enhancements */
        
        canvas {
            /* Clean canvas without effects */
        }
        
        .chart-wrapper {
            /* Subtle design without heavy shadows */
        }
        
        .chart-wrapper:hover {
            /* No hover effects for cleaner look */
        }
        
        .tab::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: #1e3a8a;
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        
        .tab {
            position: relative;
        }
        
        .tab.active::after {
            transform: scaleX(1);
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #111111;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DxGPT Diagnostic Benchmarking Analysis</h1>
        
        <div class="controls">
            <h3>Diagnostic Analysis Platform</h3>
            
            <div class="file-upload-section">
                <div class="instructions-header">
                    <div class="instructions-badge">DATA INPUT</div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                    <div style="text-align: center; padding: 12px; background: #0a0a0a; border-radius: 6px; border: 1px solid #1f1f1f;">
                        <div style="color: #9ca3af; font-weight: 400; margin-bottom: 6px;">Semantic Evaluation</div>
                        <div style="color: #6b7280; font-size: 12px; font-family: 'Courier New', monospace;">*semantic_evaluation*.json</div>
                    </div>
                    <div style="text-align: center; padding: 12px; background: #0a0a0a; border-radius: 6px; border: 1px solid #1f1f1f;">
                        <div style="color: #9ca3af; font-weight: 400; margin-bottom: 6px;">Severity Evaluation</div>
                        <div style="color: #6b7280; font-size: 12px; font-family: 'Courier New', monospace;">*severity_evaluation*.json</div>
                    </div>
                </div>
                
                <details style="margin-bottom: 16px;">
                    <summary style="cursor: pointer; color: #6b7280; font-size: 12px; font-weight: 400; margin-bottom: 12px;">View Expected JSON Structure</summary>
                    <div style="background: #0a0a0a; border-radius: 6px; padding: 12px; overflow-x: auto; border: 1px solid #1f1f1f;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div>
                                <div style="color: #9ca3af; font-weight: 400; margin-bottom: 6px; font-size: 12px;">Semantic Evaluation</div>
                                <pre style="margin: 0; color: #d1d5db; font-size: 9px; background: #050505; padding: 8px; border-radius: 4px; overflow-x: auto;">{
  "metadata": {"experiment_name": "..."},
  "evaluations": [{
    "case_id": 1,
    "gdx_set": ["Disease name"],
    "best_match": {
      "gdx": "Disease name",
      "ddx": "DDX Disease name", 
      "score": 0.95
    },
    "ddx_semantic_scores": {
      "DDX Disease name": [0.95, ...]
    }
  }]
}</pre>
                            </div>
                            <div>
                                <div style="color: #9ca3af; font-weight: 400; margin-bottom: 6px; font-size: 12px;">Severity Evaluation</div>
                                <pre style="margin: 0; color: #d1d5db; font-size: 9px; background: #050505; padding: 8px; border-radius: 4px; overflow-x: auto;">{
  "metadata": {"experiment_name": "..."},
  "evaluations": [{
    "id": 1,
    "final_score": 0.2222,
    "optimist": {"n": 5, "score": 0.2222},
    "pessimist": {"n": 0, "score": 0.0},
    "gdx": {
      "disease": "Disease name",
      "severity": "S9"
    },
    "ddx_list": [{
      "disease": "DDX Disease",
      "severity": "S7",
      "distance": 2,
      "score": 0.2222
    }]
  }]
}</pre>
                            </div>
                        </div>
                    </div>
                </details>
                
                <div class="drag-drop-container" style="grid-template-columns: 1fr;">
                    <div class="drag-drop-zone" id="unifiedZone">
                        <h4 style="margin: 0 0 6px 0; font-weight: 400; color: #d1d5db;">Drop JSON files here</h4>
                        <p style="margin: 0 0 12px 0; color: #6b7280; font-size: 12px;">Automatically detects file types</p>
                        <input type="file" id="unifiedFile" accept=".json" multiple style="display: none;">
                        <div id="fileStatus" style="margin-top: 12px; font-size: 12px;"></div>
                    </div>
                </div>
                
                <!-- Hidden original inputs for backward compatibility -->
                <input type="file" id="semanticFile" accept=".json" style="display: none;">
                <input type="file" id="severityFile" accept=".json" style="display: none;">
            </div>
            
            <div class="action-buttons">
                <button class="primary-button" onclick="processFiles()">Generate Analysis</button>
                <button class="secondary-button" onclick="downloadAllCharts()">Download Charts</button>
            </div>
            
            <div id="dataStatus" style="text-align: center; margin-top: 12px;"></div>
        </div>

        <!-- Tab Navigation -->
        <div class="tabs" id="tabNavigation" style="display: none;">
            <div class="tab active" data-chart="statisticsSummary">Statistical Summary</div>
            <div class="tab" data-chart="semanticBiasChart">Combined Bias</div>
            <div class="tab" data-chart="semanticPlots">Semantic Plots</div>
            <div class="tab" data-chart="severityPlots">Severity Plots</div>
        </div>

        <div id="chartsContainer"></div>
    </div>

    <script>
        let semanticData = null;
        let severityData = null;
        let charts = {};
        
        // Set Chart.js defaults for dark theme
        Chart.defaults.color = '#ffffff';
        Chart.defaults.borderColor = '#374151';
        Chart.defaults.backgroundColor = '#1f2937';
        
        // Simple KDE implementation without d3
        function calculateKDE(data, bandwidth, min, max, steps = 100) {
            if (!data || data.length === 0) return [];
            
            const kde = [];
            const stepSize = (max - min) / steps;
            
            for (let i = 0; i <= steps; i++) {
                const x = min + i * stepSize;
                let sum = 0;
                
                data.forEach(d => {
                    const diff = (x - d) / bandwidth;
                    // Gaussian kernel
                    sum += Math.exp(-0.5 * diff * diff) / Math.sqrt(2 * Math.PI);
                });
                
                kde.push({
                    x: x,
                    y: sum / (data.length * bandwidth)
                });
            }
            
            return kde;
        }

        // File handling
        document.getElementById('semanticFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        semanticData = JSON.parse(e.target.result);
                        updateFileStatus('semanticZone', file.name, true);
                        updateStatus();
                        if (semanticData && severityData) {
                            minimizeControls();
                        }
                    } catch (err) {
                        alert('Error parsing semantic JSON file');
                        updateFileStatus('semanticZone', '', false);
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('severityFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        severityData = JSON.parse(e.target.result);
                        updateFileStatus('severityZone', file.name, true);
                        updateStatus();
                        if (semanticData && severityData) {
                            minimizeControls();
                        }
                    } catch (err) {
                        alert('Error parsing severity JSON file');
                        updateFileStatus('severityZone', '', false);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Unified Drag and Drop functionality
        function setupDragAndDrop() {
            const unifiedZone = document.getElementById('unifiedZone');
            const unifiedFile = document.getElementById('unifiedFile');

            // Click to upload
            unifiedZone.addEventListener('click', () => {
                unifiedFile.click();
            });

            // Handle file input change
            unifiedFile.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                processMultipleFiles(files);
            });

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                unifiedZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                unifiedZone.addEventListener(eventName, () => unifiedZone.classList.add('drag-over'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                unifiedZone.addEventListener(eventName, () => unifiedZone.classList.remove('drag-over'), false);
            });

            // Handle dropped files
            unifiedZone.addEventListener('drop', (e) => {
                const files = Array.from(e.dataTransfer.files);
                processMultipleFiles(files);
            }, false);
        }

        function processMultipleFiles(files) {
            const jsonFiles = files.filter(file => file.type === 'application/json' || file.name.endsWith('.json'));
            
            if (jsonFiles.length === 0) {
                alert('Please drop valid JSON files');
                return;
            }

            let processed = 0;
            const expectedFiles = jsonFiles.length;

            jsonFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        const fileName = file.name.toLowerCase();
                        
                        // Auto-detect file type based on filename
                        if (fileName.includes('semantic_evaluation') || fileName.includes('semantic')) {
                            semanticData = data;
                            updateUnifiedFileStatus('semantic', file.name, true);
                        } else if (fileName.includes('severity_evaluation') || fileName.includes('severity')) {
                            severityData = data;
                            updateUnifiedFileStatus('severity', file.name, true);
                        } else {
                            // Try to detect by content structure
                            if (data.evaluations && data.evaluations[0]) {
                                const firstEval = data.evaluations[0];
                                if (firstEval.gdx_set || firstEval.best_match) {
                                    semanticData = data;
                                    updateUnifiedFileStatus('semantic', file.name, true);
                                } else if (firstEval.final_score !== undefined && firstEval.optimist && firstEval.pessimist) {
                                    severityData = data;
                                    updateUnifiedFileStatus('severity', file.name, true);
                                }
                            }
                        }
                        
                        processed++;
                        if (processed === expectedFiles) {
                            updateStatus();
                            if (semanticData && severityData) {
                                minimizeControls();
                            }
                        }
                    } catch (err) {
                        alert('Error parsing JSON file: ' + file.name);
                    }
                };
                reader.readAsText(file);
            });
        }

        function updateUnifiedFileStatus(type, fileName, success) {
            const statusDiv = document.getElementById('fileStatus');
            const currentStatus = statusDiv.innerHTML;
            
            const semanticLoaded = semanticData !== null;
            const severityLoaded = severityData !== null;
            
            let statusHTML = '';
            if (semanticLoaded) {
                statusHTML += '<div style="color: #34d399;">✅ Semantic evaluation loaded</div>';
            }
            if (severityLoaded) {
                statusHTML += '<div style="color: #34d399;">✅ Severity evaluation loaded</div>';
            }
            
            if (!semanticLoaded && !severityLoaded) {
                statusHTML = '<div style="color: #6b7280;">No files loaded</div>';
            } else if (!semanticLoaded || !severityLoaded) {
                const missing = !semanticLoaded ? 'semantic_evaluation.json' : 'severity_evaluation.json';
                statusHTML += `<div style="color: #f59e0b;">⚠️ Still need: ${missing}</div>`;
            }
            
            statusDiv.innerHTML = statusHTML;
        }


        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }



        // Initialize drag and drop when DOM is loaded
        document.addEventListener('DOMContentLoaded', setupDragAndDrop);

        function updateStatus() {
            const status = document.getElementById('dataStatus');
            if (semanticData && severityData) {
                status.className = 'success';
                status.textContent = 'Both files loaded successfully. Click "Generate Visualizations" to proceed.';
            } else if (semanticData || severityData) {
                status.className = 'warning';
                status.textContent = `Loaded: ${semanticData ? 'Semantic' : ''} ${severityData ? 'Severity' : ''}. Please load both files.`;
            }
        }
        
        function minimizeControls() {
            const controls = document.querySelector('.controls');
            const dropZones = document.querySelector('.drag-drop-container');
            if (controls && dropZones) {
                dropZones.style.display = 'none';
                controls.style.padding = '15px 30px';
                controls.style.marginBottom = '20px';
            }
        }

        function processFiles() {
            if (!semanticData || !severityData) {
                alert('Please load both JSON files first');
                return;
            }
            
            const container = document.getElementById('chartsContainer');
            container.innerHTML = '';
            
            try {
                // Show tab navigation
                document.getElementById('tabNavigation').style.display = 'flex';
                
                // Add statistics summary first
                createStatisticsSummary();
                
                // Generate only requested visualizations
                createSemanticBiasChart();
                createSemanticPlotsSection();
                createSeverityPlotsSection();
                
                // Setup tab functionality
                setupTabs();
                
                // Show first chart by default
                showChart('statisticsSummary');
            } catch (error) {
                console.error('Error creating charts:', error);
                alert('Error creating charts: ' + error.message);
            }
        }
        
        function createStatisticsSummary() {
            // Calculate semantic statistics
            const semanticScores = semanticData.evaluations.map(e => e.best_match.score);
            const semanticMean = semanticScores.reduce((a, b) => a + b, 0) / semanticScores.length;
            const semanticStdDev = Math.sqrt(
                semanticScores.reduce((sq, n) => sq + Math.pow(n - semanticMean, 2), 0) / semanticScores.length
            );
            
            // Calculate severity statistics
            const severityScores = severityData.evaluations.map(e => e.final_score);
            const severityMean = severityScores.reduce((a, b) => a + b, 0) / severityScores.length;
            const severityStdDev = Math.sqrt(
                severityScores.reduce((sq, n) => sq + Math.pow(n - severityMean, 2), 0) / severityScores.length
            );
            
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'chart-container active';
            summaryDiv.id = 'statisticsSummary';
            summaryDiv.innerHTML = `
                <div class="chart-wrapper">
                    <h3>Statistical Summary</h3>
                    <p>Comprehensive analysis of semantic similarity and severity evaluation metrics</p>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h4>Semantic Evaluation</h4>
                            <div class="stat-value">${semanticMean.toFixed(3)}</div>
                            <div class="stat-label">Mean Score</div>
                            <div class="stat-row">
                                <span class="stat-label">Std Dev</span>
                                <span>${semanticStdDev.toFixed(3)}</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Range</span>
                                <span>${Math.min(...semanticScores).toFixed(3)} – ${Math.max(...semanticScores).toFixed(3)}</span>
                            </div>
                        </div>
                        <div class="stat-card">
                            <h4>Severity Evaluation</h4>
                            <div class="stat-value">${severityMean.toFixed(3)}</div>
                            <div class="stat-label">Mean Score</div>
                            <div class="stat-row">
                                <span class="stat-label">Std Dev</span>
                                <span>${severityStdDev.toFixed(3)}</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Range</span>
                                <span>${Math.min(...severityScores).toFixed(3)} – ${Math.max(...severityScores).toFixed(3)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('chartsContainer').appendChild(summaryDiv);
        }

        // New Chart: Semantic Score Histogram with KDE
        function createSemanticScoreHistogram() {
            const ctx = createChartWrapper('semanticScoreHistogram', 
                'Semantic Score Distribution',
                'Histogram showing the distribution of semantic similarity scores with a kernel density estimation (KDE) curve overlay for smooth distribution visualization.');
            
            // Collect all semantic scores
            const allSemanticScores = [];
            semanticData.evaluations.forEach(evaluation => {
                allSemanticScores.push(evaluation.best_match.score);
            });
            
            // Create histogram bins
            const bins = 25;
            const binWidth = 1.0 / bins;
            const histogram = new Array(bins).fill(0);
            
            allSemanticScores.forEach(score => {
                const binIndex = Math.min(Math.floor(score / binWidth), bins - 1);
                histogram[binIndex]++;
            });
            
            // Create bin labels
            const binLabels = [];
            const histogramData = [];
            for (let i = 0; i < bins; i++) {
                const binStart = i * binWidth;
                const binEnd = (i + 1) * binWidth;
                binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
                histogramData.push(histogram[i]);
            }
            
            // Calculate KDE
            const kde = calculateKDE(allSemanticScores, 0.05, 0, 1, bins);
            const maxHistCount = Math.max(...histogram);
            const maxKDE = Math.max(...kde.map(d => d.y));
            
            // Scale KDE to match histogram height
            const kdeScaled = kde.map((point, i) => ({
                x: binLabels[Math.floor(i * bins / kde.length)] || binLabels[binLabels.length - 1],
                y: (point.y / maxKDE) * maxHistCount * 1.1
            }));

            charts.semanticScoreHistogram = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Semantic Score Count',
                        data: histogramData,
                        backgroundColor: 'rgba(99, 102, 241, 0.6)',
                        borderColor: 'rgba(99, 102, 241, 1)',
                        borderWidth: 1,
                        order: 2,
                        barPercentage: 0.95,
                        categoryPercentage: 1.0
                    }, {
                        label: 'KDE Curve',
                        data: kdeScaled,
                        type: 'line',
                        borderColor: 'rgba(245, 158, 11, 0.9)',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.4,
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round',
                        order: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: {
                                    size: 12
                                },
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 20,
                                usePointStyle: true
                            },
                            align: 'center',
                            fullSize: true,
                            maxHeight: 100
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Semantic Similarity Score Range',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxRotation: 45,
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count / Density',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        }
                    }
                }
            });
        }

        function createChartWrapper(id, title, description) {
            const container = document.createElement('div');
            container.className = 'chart-container';
            container.id = id + 'Container';
            
            const wrapper = document.createElement('div');
            wrapper.className = 'chart-wrapper';
            wrapper.innerHTML = `
                <h3>${title}</h3>
                <button class="download-btn" onclick="downloadChart('${id}')">Download PNG</button>
                ${description ? `<p>${description}</p>` : ''}
                <canvas id="${id}"></canvas>
            `;
            container.appendChild(wrapper);
            document.getElementById('chartsContainer').appendChild(container);
            return document.getElementById(id).getContext('2d');
        }

        // New Section: Semantic Plots
        function createSemanticPlotsSection() {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'chart-container';
            sectionDiv.id = 'semanticPlotsContainer';
            sectionDiv.innerHTML = `
                <div class="chart-wrapper">
                    <h3>Semantic Analysis Plots</h3>
                    <p>Comprehensive semantic similarity analysis including score distribution and ridge plots</p>
                    
                    <!-- Sub-navigation for semantic plots -->
                    <div style="display: flex; gap: 1px; margin-bottom: 30px; border-bottom: 1px solid #1f2937;">
                        <button class="semantic-subtab active" data-subchart="semanticScoreHistogram" style="
                            padding: 10px 20px;
                            background: transparent;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            font-size: 12px;
                            text-transform: uppercase;
                            letter-spacing: 0.02em;
                            border-bottom: 2px solid transparent;
                        ">Score Histogram</button>
                        <button class="semantic-subtab" data-subchart="ridgePlot" style="
                            padding: 10px 20px;
                            background: transparent;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            font-size: 12px;
                            text-transform: uppercase;
                            letter-spacing: 0.02em;
                            border-bottom: 2px solid transparent;
                        ">Ridge Plot</button>
                    </div>
                    
                    <!-- Containers for each semantic plot -->
                    <div id="semanticScoreHistogramSection" class="semantic-subchart active">
                        <h4 style="color: #e5e7eb; font-weight: 300; margin-bottom: 15px;">Semantic Score Distribution</h4>
                        <p style="color: #9ca3af; font-size: 0.875rem; margin-bottom: 20px;">Histogram showing the distribution of semantic similarity scores with a kernel density estimation (KDE) curve overlay.</p>
                        <canvas id="semanticScoreHistogram"></canvas>
                    </div>
                    
                    <div id="ridgePlotSection" class="semantic-subchart" style="display: none;">
                        <h4 style="color: #e5e7eb; font-weight: 300; margin-bottom: 15px;">Ridge Plot: Semantic Score Distributions</h4>
                        <p style="color: #9ca3af; font-size: 0.875rem; margin-bottom: 20px;">Overlapping density distributions of semantic scores grouped by GDX severity level.</p>
                        <canvas id="ridgePlot"></canvas>
                    </div>
                </div>
            `;
            document.getElementById('chartsContainer').appendChild(sectionDiv);
            
            // Create the individual charts
            createSemanticScoreHistogram();
            createRidgePlot();
            
            // Setup semantic sub-navigation
            setupSemanticSubTabs();
        }

        // New Section: Severity Plots
        function createSeverityPlotsSection() {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'chart-container';
            sectionDiv.id = 'severityPlotsContainer';
            sectionDiv.innerHTML = `
                <div class="chart-wrapper">
                    <h3>Severity Analysis Plots</h3>
                    <p>Comprehensive severity evaluation analysis including GDX vs DDX comparison, distribution levels, and evaluator balance</p>
                    
                    <!-- Sub-navigation for severity plots -->
                    <div style="display: flex; gap: 1px; margin-bottom: 30px; border-bottom: 1px solid #1f2937;">
                        <button class="severity-subtab active" data-subchart="gdxDdxSeverityChart" style="
                            padding: 10px 20px;
                            background: transparent;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            font-size: 12px;
                            text-transform: uppercase;
                            letter-spacing: 0.02em;
                            border-bottom: 2px solid transparent;
                        ">GDX vs DDX</button>
                        <button class="severity-subtab" data-subchart="severityLevelsChart" style="
                            padding: 10px 20px;
                            background: transparent;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            font-size: 12px;
                            text-transform: uppercase;
                            letter-spacing: 0.02em;
                            border-bottom: 2px solid transparent;
                        ">Severity Levels</button>
                        <button class="severity-subtab" data-subchart="optimistPessimistChart" style="
                            padding: 10px 20px;
                            background: transparent;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            font-size: 12px;
                            text-transform: uppercase;
                            letter-spacing: 0.02em;
                            border-bottom: 2px solid transparent;
                        ">Evaluator Balance</button>
                    </div>
                    
                    <!-- Containers for each severity plot -->
                    <div id="gdxDdxSeverityChartSection" class="severity-subchart active">
                        <h4 style="color: #e5e7eb; font-weight: 300; margin-bottom: 15px;">GDX vs DDX Severity Comparison</h4>
                        <p style="color: #9ca3af; font-size: 0.875rem; margin-bottom: 20px;">Shows the relationship between ground truth (GDX) severity and the mean of differential diagnoses (DDX) severities with boxplots.</p>
                        <canvas id="gdxDdxSeverityChart"></canvas>
                    </div>
                    
                    <div id="severityLevelsChartSection" class="severity-subchart" style="display: none;">
                        <h4 style="color: #e5e7eb; font-weight: 300; margin-bottom: 15px;">Severity Levels Distribution</h4>
                        <p style="color: #9ca3af; font-size: 0.875rem; margin-bottom: 20px;">Histogram showing the distribution of severity levels for GDX and DDX with KDE curves.</p>
                        <canvas id="severityLevelsChart"></canvas>
                    </div>
                    
                    <div id="optimistPessimistChartSection" class="severity-subchart" style="display: none;">
                        <h4 style="color: #e5e7eb; font-weight: 300; margin-bottom: 15px;">Optimist vs Pessimist Evaluator Balance</h4>
                        <p style="color: #9ca3af; font-size: 0.875rem; margin-bottom: 20px;">Distribution by n (1-5) for optimist and pessimist cases with center totals.</p>
                        <canvas id="optimistPessimistChart"></canvas>
                    </div>
                </div>
            `;
            document.getElementById('chartsContainer').appendChild(sectionDiv);
            
            // Create the individual charts
            createGDXvsDDXSeverityChart();
            createSeverityLevelsChart();
            createOptimistPessimistBalance();
            
            // Setup severity sub-navigation
            setupSeveritySubTabs();
        }

        // Chart 1: Semantic Bias Evaluation
        function createSemanticBiasChart() {
            const ctx = createChartWrapper('semanticBiasChart', 
                'Combined Bias Evaluation Plot',
                'Each point represents a case positioned by its severity final score (horizontal) and semantic similarity score (vertical). Cases with more optimist evaluators appear on the left, while those with more pessimist evaluators appear on the right.');
            
            const scatterData = [];
            let maxScore = 0;
            
            // Process each case to get semantic scores and bias
            semanticData.evaluations.forEach((evaluation) => {
                const bestScore = evaluation.best_match.score;
                
                // Find corresponding severity evaluation
                const sevEval = severityData.evaluations.find(s => s.id === evaluation.case_id);
                if (!sevEval) return;
                
                // Use the final_score for position and n counts for direction
                const finalScore = sevEval.final_score;
                maxScore = Math.max(maxScore, finalScore);
                
                // Determine if optimist or pessimist based on counts
                if (sevEval.optimist.n > sevEval.pessimist.n) {
                    // More optimists - place on left (negative)
                    scatterData.push({
                        x: -finalScore,
                        y: bestScore,
                        type: 'optimist',
                        caseId: evaluation.case_id
                    });
                } else if (sevEval.pessimist.n > sevEval.optimist.n) {
                    // More pessimists - place on right (positive)
                    scatterData.push({
                        x: finalScore,
                        y: bestScore,
                        type: 'pessimist',
                        caseId: evaluation.case_id
                    });
                } else {
                    // Equal - place at center
                    scatterData.push({
                        x: 0,
                        y: bestScore,
                        type: 'neutral',
                        caseId: evaluation.case_id
                    });
                }
            });

            const optimistData = scatterData.filter(d => d.type === 'optimist');
            const pessimistData = scatterData.filter(d => d.type === 'pessimist');
            const neutralData = scatterData.filter(d => d.type === 'neutral');
            
            // Calculate mean points
            const allMeanX = scatterData.length > 0 ? scatterData.reduce((sum, d) => sum + d.x, 0) / scatterData.length : 0;
            const allMeanY = scatterData.length > 0 ? scatterData.reduce((sum, d) => sum + d.y, 0) / scatterData.length : 0;
            
            const optimistMeanX = optimistData.length > 0 ? 
                optimistData.reduce((sum, d) => sum + d.x, 0) / optimistData.length : 0;
            const optimistMeanY = optimistData.length > 0 ? 
                optimistData.reduce((sum, d) => sum + d.y, 0) / optimistData.length : 0;
            
            const pessimistMeanX = pessimistData.length > 0 ? 
                pessimistData.reduce((sum, d) => sum + d.x, 0) / pessimistData.length : 0;
            const pessimistMeanY = pessimistData.length > 0 ? 
                pessimistData.reduce((sum, d) => sum + d.y, 0) / pessimistData.length : 0;

            const neutralMeanX = neutralData.length > 0 ? 
                neutralData.reduce((sum, d) => sum + d.x, 0) / neutralData.length : 0;
            const neutralMeanY = neutralData.length > 0 ? 
                neutralData.reduce((sum, d) => sum + d.y, 0) / neutralData.length : 0;

            // Create horizontal histogram data including neutral zone
            const horizontalBins = 40;
            const horizontalBinWidth = (maxScore * 2.4) / horizontalBins;
            const horizontalHistogram = new Array(horizontalBins).fill(0);
            
            scatterData.forEach(d => {
                const binIndex = Math.floor((d.x + maxScore * 1.2) / horizontalBinWidth);
                if (binIndex >= 0 && binIndex < horizontalBins) {
                    horizontalHistogram[binIndex]++;
                }
            });
            
            // Create histogram bars as rectangles at bottom
            const histogramData = [];
            const maxHistCount = Math.max(...horizontalHistogram);
            const histScale = 0.18; // Height scale for histogram
            
            for (let i = 0; i < horizontalBins; i++) {
                if (horizontalHistogram[i] > 0) {
                    const x = -maxScore * 1.2 + (i + 0.5) * horizontalBinWidth;
                    const height = (horizontalHistogram[i] / maxHistCount) * histScale;
                    
                    // Create a dense set of points to form a bar
                    const barWidth = horizontalBinWidth * 0.9;
                    const pointsPerBar = 25;
                    
                    for (let px = 0; px < pointsPerBar; px++) {
                        const xOffset = (px / pointsPerBar - 0.5) * barWidth;
                        for (let py = 0; py <= 12; py++) {
                            histogramData.push({
                                x: x + xOffset,
                                y: -0.05 + (height * py / 12)
                            });
                        }
                    }
                }
            }

            charts.semanticBiasChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Distribution',
                        data: histogramData,
                        backgroundColor: 'rgba(156, 163, 175, 0.3)',
                        borderColor: 'transparent',
                        pointRadius: 2,
                        pointHoverRadius: 2,
                        showLine: false,
                        order: 10
                    }, {
                        label: 'Optimist Majority',
                        data: optimistData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(59, 130, 246, 0.48)',
                        borderColor: 'rgba(59, 130, 246, 0.8)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 3
                    }, {
                        label: 'Pessimist Majority',
                        data: pessimistData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(239, 68, 68, 0.48)',
                        borderColor: 'rgba(239, 68, 68, 0.8)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 3
                    }, {
                        label: 'Balanced',
                        data: neutralData.map(d => ({x: d.x, y: d.y})),
                        backgroundColor: 'rgba(128, 128, 128, 0.48)',
                        borderColor: 'rgba(128, 128, 128, 0.8)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 3
                    }, {
                        label: 'Overall Mean',
                        data: [{x: allMeanX, y: allMeanY}],
                        backgroundColor: 'rgba(255, 235, 59, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }, {
                        label: 'Optimist Mean',
                        data: optimistData.length > 0 ? [{x: optimistMeanX, y: optimistMeanY}] : [],
                        backgroundColor: 'rgba(54, 162, 235, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }, {
                        label: 'Pessimist Mean',
                        data: pessimistData.length > 0 ? [{x: pessimistMeanX, y: pessimistMeanY}] : [],
                        backgroundColor: 'rgba(255, 99, 132, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }, {
                        label: 'Neutral Mean',
                        data: neutralData.length > 0 ? [{x: neutralMeanX, y: neutralMeanY}] : [],
                        backgroundColor: 'rgba(156, 163, 175, 1)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 2,
                        pointRadius: 10,
                        pointHoverRadius: 12,
                        pointStyle: 'rectRot',
                        order: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 30,
                            bottom: 30,
                            left: 30,
                            right: 30
                        }
                    },
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: {
                                    size: 12
                                },
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 20,
                                usePointStyle: true
                            },
                            align: 'center',
                            fullSize: true,
                            maxHeight: 100
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            position: 'bottom',
                            title: {
                                display: true,
                                text: '← Optimist Majority | Severity Score | Pessimist Majority →',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    return Math.abs(value).toFixed(3);
                                }
                            },
                            min: -maxScore * 1.2,
                            max: maxScore * 1.2,
                            grid: {
                                drawBorder: true,
                                borderWidth: 1,
                                borderColor: 'black',
                                lineWidth: function(context) {
                                    return context.tick.value === 0 ? 2 : 1;
                                },
                                color: function(context) {
                                    return context.tick.value === 0 ? '#374151' : '#1f2937';
                                }
                            }
                        },
                        y: {
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Semantic Level',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            min: -0.05,
                            max: 1.0,
                            grid: {
                                drawBorder: true,
                                borderWidth: 1,
                                borderColor: '#374151',
                                color: '#1f2937'
                            }
                        }
                    }
                }
            });
        }

        // Chart 2: GDX vs DDX Severity
        function createGDXvsDDXSeverityChart() {
            const ctx = createChartWrapper('gdxDdxSeverityChart', 
                'GDX vs DDX Severity Comparison',
                'Shows the relationship between ground truth (GDX) severity and the mean of differential diagnoses (DDX) severities. Blue points represent cases where DDX severities are lower (optimistic), red points where DDX severities are higher (pessimistic). The dashed line represents perfect match.');
            
            const optimistData = [];
            const pessimistData = [];
            const perfectMatch = [];
            
            // Group data by GDX severity for boxplots
            const gdxGroups = {};
            
            severityData.evaluations.forEach(evaluation => {
                const gdxSeverity = parseInt(evaluation.gdx.severity.substring(1));
                
                if (!gdxGroups[gdxSeverity]) {
                    gdxGroups[gdxSeverity] = {
                        optimist: [],
                        pessimist: [],
                        all: []
                    };
                }
                
                // Calculate mean DDX severity for optimists and pessimists
                let optimistSevs = [];
                let pessimistSevs = [];
                
                evaluation.ddx_list.forEach(ddx => {
                    const ddxSeverity = parseInt(ddx.severity.substring(1));
                    gdxGroups[gdxSeverity].all.push(ddxSeverity);
                    
                    // Pessimists: DDX severity HIGHER than GDX (above the line)
                    if (ddxSeverity > gdxSeverity) {
                        pessimistSevs.push(ddxSeverity);
                        gdxGroups[gdxSeverity].pessimist.push(ddxSeverity);
                    } 
                    // Optimists: DDX severity LOWER than GDX (below the line)
                    else if (ddxSeverity < gdxSeverity) {
                        optimistSevs.push(ddxSeverity);
                        gdxGroups[gdxSeverity].optimist.push(ddxSeverity);
                    }
                });
                
                // Add mean points for each case
                if (optimistSevs.length > 0) {
                    const meanOptimist = optimistSevs.reduce((a, b) => a + b, 0) / optimistSevs.length;
                    optimistData.push({x: gdxSeverity, y: meanOptimist});
                }
                
                if (pessimistSevs.length > 0) {
                    const meanPessimist = pessimistSevs.reduce((a, b) => a + b, 0) / pessimistSevs.length;
                    pessimistData.push({x: gdxSeverity, y: meanPessimist});
                }
            });
            
            // Create perfect match line
            for (let i = 0; i <= 10; i++) {
                perfectMatch.push({x: i, y: i});
            }
            
            // Create bottom axis histogram for GDX severity distribution
            const gdxSeverityHist = {};
            for (let i = 0; i <= 10; i++) {
                gdxSeverityHist[i] = 0;
            }
            
            severityData.evaluations.forEach(evaluation => {
                const gdxSeverity = parseInt(evaluation.gdx.severity.substring(1));
                gdxSeverityHist[gdxSeverity]++;
            });
            
            // Create histogram bars as points at bottom
            const bottomHistogramData = [];
            const maxGdxCount = Math.max(...Object.values(gdxSeverityHist));
            const histScale = 0.6; // Height scale for histogram
            
            for (let severity = 0; severity <= 10; severity++) {
                const count = gdxSeverityHist[severity];
                if (count > 0) {
                    const height = (count / maxGdxCount) * histScale;
                    const barWidth = 0.6;
                    const pointsPerBar = 15;
                    
                    for (let px = 0; px < pointsPerBar; px++) {
                        const xOffset = (px / pointsPerBar - 0.5) * barWidth;
                        for (let py = 0; py <= 8; py++) {
                            bottomHistogramData.push({
                                x: severity + xOffset,
                                y: -0.3 + (height * py / 8)
                            });
                        }
                    }
                }
            }
            
            // Create simple boxplot data
            const boxplotData = [];
            const boxplotFillData = [];
            Object.keys(gdxGroups).forEach(gdxSev => {
                const gdxSeverity = parseInt(gdxSev);
                const optimistValues = gdxGroups[gdxSeverity].optimist;
                const pessimistValues = gdxGroups[gdxSeverity].pessimist;
                
                // Add minimalistic optimist boxplots (blue) - left side, more separated
                if (optimistValues.length > 0) {
                    const sorted = optimistValues.sort((a, b) => a - b);
                    const q1 = sorted[Math.floor(sorted.length * 0.25)];
                    const median = sorted[Math.floor(sorted.length * 0.5)];
                    const q3 = sorted[Math.floor(sorted.length * 0.75)];
                    const min = sorted[0];
                    const max = sorted[sorted.length - 1];
                    
                    const boxLeft = gdxSeverity - 0.35;
                    const boxRight = gdxSeverity - 0.15;
                    const centerX = (boxLeft + boxRight) / 2;
                    
                    // Store box fill data for aesthetics
                    boxplotFillData.push({
                        type: 'optimist',
                        boxLeft: boxLeft,
                        boxRight: boxRight,
                        q1: q1,
                        q3: q3,
                        median: median
                    });
                    
                    // Box outline as line segments
                    boxplotData.push({x: boxLeft, y: q1, x2: boxRight, y2: q1, type: 'optimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q3, x2: boxRight, y2: q3, type: 'optimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q1, x2: boxLeft, y2: q3, type: 'optimist', lineType: 'vertical'});
                    boxplotData.push({x: boxRight, y: q1, x2: boxRight, y2: q3, type: 'optimist', lineType: 'vertical'});
                    
                    // Median line
                    boxplotData.push({x: boxLeft, y: median, x2: boxRight, y2: median, type: 'optimist', lineType: 'median'});
                    
                    // Whiskers
                    boxplotData.push({x: centerX, y: min, x2: centerX, y2: q1, type: 'optimist', lineType: 'whisker'});
                    boxplotData.push({x: centerX, y: q3, x2: centerX, y2: max, type: 'optimist', lineType: 'whisker'});
                }
                
                // Add minimalistic pessimist boxplots (red) - right side, more separated
                if (pessimistValues.length > 0) {
                    const sorted = pessimistValues.sort((a, b) => a - b);
                    const q1 = sorted[Math.floor(sorted.length * 0.25)];
                    const median = sorted[Math.floor(sorted.length * 0.5)];
                    const q3 = sorted[Math.floor(sorted.length * 0.75)];
                    const min = sorted[0];
                    const max = sorted[sorted.length - 1];
                    
                    const boxLeft = gdxSeverity + 0.15;
                    const boxRight = gdxSeverity + 0.35;
                    const centerX = (boxLeft + boxRight) / 2;
                    
                    // Store box fill data for aesthetics
                    boxplotFillData.push({
                        type: 'pessimist',
                        boxLeft: boxLeft,
                        boxRight: boxRight,
                        q1: q1,
                        q3: q3,
                        median: median
                    });
                    
                    // Box outline as line segments
                    boxplotData.push({x: boxLeft, y: q1, x2: boxRight, y2: q1, type: 'pessimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q3, x2: boxRight, y2: q3, type: 'pessimist', lineType: 'horizontal'});
                    boxplotData.push({x: boxLeft, y: q1, x2: boxLeft, y2: q3, type: 'pessimist', lineType: 'vertical'});
                    boxplotData.push({x: boxRight, y: q1, x2: boxRight, y2: q3, type: 'pessimist', lineType: 'vertical'});
                    
                    // Median line
                    boxplotData.push({x: boxLeft, y: median, x2: boxRight, y2: median, type: 'pessimist', lineType: 'median'});
                    
                    // Whiskers
                    boxplotData.push({x: centerX, y: min, x2: centerX, y2: q1, type: 'pessimist', lineType: 'whisker'});
                    boxplotData.push({x: centerX, y: q3, x2: centerX, y2: max, type: 'pessimist', lineType: 'whisker'});
                }
            });

            // Custom plugin for drawing minimalistic boxplots with faded fills
            const boxplotPlugin = {
                id: 'minimalBoxplots',
                afterDatasetsDraw: function(chart) {
                    const ctx = chart.ctx;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y;
                    
                    // First draw the filled areas
                    boxplotFillData.forEach(box => {
                        const leftPx = xScale.getPixelForValue(box.boxLeft);
                        const rightPx = xScale.getPixelForValue(box.boxRight);
                        const q1Px = yScale.getPixelForValue(box.q1);
                        const q3Px = yScale.getPixelForValue(box.q3);
                        const medianPx = yScale.getPixelForValue(box.median);
                        
                        ctx.save();
                        
                        const isOptimist = box.type === 'optimist';
                        const baseColor = isOptimist ? [59, 130, 246] : [239, 68, 68];
                        
                        // Upper box fill (Q3 to median) - more transparent
                        ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.12)`;
                        ctx.fillRect(leftPx, q3Px, rightPx - leftPx, medianPx - q3Px);
                        
                        // Lower box fill (median to Q1) - slightly more opaque
                        ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.18)`;
                        ctx.fillRect(leftPx, medianPx, rightPx - leftPx, q1Px - medianPx);
                        
                        ctx.restore();
                    });
                    
                    // Then draw the minimal line elements
                    const groupedLines = {};
                    boxplotData.forEach(line => {
                        if (!line.x2) return;
                        const key = `${Math.round(line.x * 10)}:${line.type}`;
                        if (!groupedLines[key]) {
                            groupedLines[key] = {
                                type: line.type,
                                lines: []
                            };
                        }
                        groupedLines[key].lines.push(line);
                    });
                    
                    // Draw minimal line elements for each boxplot
                    Object.values(groupedLines).forEach(group => {
                        const lines = group.lines;
                        const isOptimist = group.type === 'optimist';
                        const baseColor = isOptimist ? [59, 130, 246] : [239, 68, 68];
                        
                        ctx.save();
                        
                        lines.forEach(line => {
                            const x1Px = xScale.getPixelForValue(line.x);
                            const y1Px = yScale.getPixelForValue(line.y);
                            const x2Px = xScale.getPixelForValue(line.x2);
                            const y2Px = yScale.getPixelForValue(line.y2);
                            
                            ctx.beginPath();
                            ctx.moveTo(x1Px, y1Px);
                            ctx.lineTo(x2Px, y2Px);
                            
                            // Style based on line type
                            if (line.lineType === 'median') {
                                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.9)`;
                                ctx.lineWidth = 2;
                            } else if (line.lineType === 'whisker') {
                                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.5)`;
                                ctx.lineWidth = 1;
                            } else {
                                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0.7)`;
                                ctx.lineWidth = 1;
                            }
                            
                            ctx.stroke();
                        });
                        
                        ctx.restore();
                    });
                }
            };

            charts.gdxDdxSeverityChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'GDX Severity Distribution',
                        data: bottomHistogramData,
                        backgroundColor: 'rgba(156, 163, 175, 0.25)',
                        borderColor: 'transparent',
                        pointRadius: 1.5,
                        pointHoverRadius: 1.5,
                        showLine: false,
                        order: 10
                    }, {
                        label: 'Perfect Match',
                        data: perfectMatch,
                        type: 'line',
                        borderColor: 'rgba(156, 163, 175, 0.8)',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 2,
                        order: 0
                    }, {
                        label: 'Mean Optimist DDX (Below Line)',
                        data: optimistData,
                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 1
                    }, {
                        label: 'Mean Pessimist DDX (Above Line)',
                        data: pessimistData,
                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        order: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: {
                                    size: 12
                                },
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 20,
                                usePointStyle: true
                            },
                            align: 'center',
                            fullSize: true,
                            maxHeight: 100
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'GDX Severity',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                stepSize: 1
                            },
                            grid: {
                                color: '#1f2937'
                            },
                            min: 0,
                            max: 10
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Mean DDX Severity',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af',
                                stepSize: 1
                            },
                            grid: {
                                color: '#1f2937'
                            },
                            min: -0.4,
                            max: 10
                        }
                    }
                },
                plugins: [boxplotPlugin]
            });
        }

        // Chart 4: Severity Levels Distribution
        function createSeverityLevelsChart() {
            const ctx = createChartWrapper('severityLevelsChart', 
                'Severity Levels Distribution: GDX vs DDX',
                'Histogram showing the distribution of severity levels for GDX (ground truth) and DDX (differential diagnoses). GDX counts are multiplied by 5 to account for the 1:5 ratio and better visualize proportions. Includes KDE curves for smooth distribution visualization.');
            
            // Count severity levels for GDX and DDX
            const gdxCounts = {}; // S3 to S10
            const ddxCounts = {}; // S3 to S10
            
            // Initialize counts
            for (let i = 3; i <= 10; i++) {
                gdxCounts[`S${i}`] = 0;
                ddxCounts[`S${i}`] = 0;
            }
            
            // Count GDX severities
            severityData.evaluations.forEach(evaluation => {
                const gdxSeverity = evaluation.gdx.severity;
                if (gdxCounts.hasOwnProperty(gdxSeverity)) {
                    gdxCounts[gdxSeverity]++;
                }
                
                // Count DDX severities
                evaluation.ddx_list.forEach(ddx => {
                    const ddxSeverity = ddx.severity;
                    if (ddxCounts.hasOwnProperty(ddxSeverity)) {
                        ddxCounts[ddxSeverity]++;
                    }
                });
            });
            
            // Prepare data for chart
            const severityLabels = [];
            const gdxData = [];
            const ddxData = [];
            const gdxRawData = []; // For KDE calculation
            const ddxRawData = []; // For KDE calculation
            
            for (let i = 3; i <= 10; i++) {
                const severity = `S${i}`;
                severityLabels.push(severity);
                
                // Multiply GDX by 5 to account for 1:5 ratio
                const gdxCount = gdxCounts[severity] * 5;
                const ddxCount = ddxCounts[severity];
                
                gdxData.push(gdxCount);
                ddxData.push(ddxCount);
                
                // Add raw data points for KDE calculation (use actual severity number)
                for (let j = 0; j < gdxCounts[severity]; j++) {
                    gdxRawData.push(i);
                }
                for (let j = 0; j < ddxCounts[severity]; j++) {
                    ddxRawData.push(i);
                }
            }
            
            // Calculate KDE for smooth curves with better mapping
            const gdxKDE = calculateKDE(gdxRawData, 0.5, 3, 10, 200);
            const ddxKDE = calculateKDE(ddxRawData, 0.5, 3, 10, 200);
            
            // Scale KDE to match histogram heights
            const maxGdx = Math.max(...gdxData.filter(v => v > 0), 1);
            const maxDdx = Math.max(...ddxData.filter(v => v > 0), 1);
            const maxKdeGdx = gdxKDE.length > 0 ? Math.max(...gdxKDE.map(d => d.y)) : 1;
            const maxKdeDdx = ddxKDE.length > 0 ? Math.max(...ddxKDE.map(d => d.y)) : 1;
            
            // Create KDE data points that align with severity labels
            const gdxKdeScaled = [];
            const ddxKdeScaled = [];
            
            // Map continuous KDE to discrete severity levels more smoothly
            for (let i = 0; i < severityLabels.length; i++) {
                const severityNum = i + 3; // S3 = 3, S4 = 4, etc.
                
                // Find KDE values around this severity level and interpolate
                const gdxKdePoint = gdxKDE.find(d => Math.abs(d.x - severityNum) < 0.25);
                const ddxKdePoint = ddxKDE.find(d => Math.abs(d.x - severityNum) < 0.25);
                
                if (gdxKdePoint) {
                    gdxKdeScaled.push({
                        x: severityLabels[i],
                        y: (gdxKdePoint.y / maxKdeGdx) * maxGdx * 1.2
                    });
                }
                
                if (ddxKdePoint) {
                    ddxKdeScaled.push({
                        x: severityLabels[i], 
                        y: (ddxKdePoint.y / maxKdeDdx) * maxDdx * 1.2
                    });
                }
            }

            charts.severityLevelsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: severityLabels,
                    datasets: [{
                        label: 'GDX (×5 for visualization)',
                        data: gdxData,
                        backgroundColor: 'rgba(16, 185, 129, 0.6)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1,
                        order: 3,
                        barPercentage: 0.8,
                        categoryPercentage: 0.9
                    }, {
                        label: 'DDX',
                        data: ddxData,
                        backgroundColor: 'rgba(249, 115, 22, 0.6)',
                        borderColor: 'rgba(249, 115, 22, 1)',
                        borderWidth: 1,
                        order: 3,
                        barPercentage: 0.8,
                        categoryPercentage: 0.9
                    }, {
                        label: 'GDX KDE Curve',
                        data: gdxKdeScaled,
                        type: 'line',
                        borderColor: 'rgba(16, 185, 129, 0.8)',
                        backgroundColor: 'rgba(16, 185, 129, 0.05)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.4,
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round',
                        cubicInterpolationMode: 'monotone',
                        order: 1
                    }, {
                        label: 'DDX KDE Curve', 
                        data: ddxKdeScaled,
                        type: 'line',
                        borderColor: 'rgba(249, 115, 22, 0.8)',
                        backgroundColor: 'rgba(249, 115, 22, 0.05)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.4,
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round',
                        cubicInterpolationMode: 'monotone',
                        order: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ffffff',
                                font: {
                                    size: 12
                                },
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 20,
                                usePointStyle: true
                            },
                            align: 'center',
                            fullSize: true,
                            maxHeight: 100
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Severity Level',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            grid: {
                                color: '#1f2937'
                            }
                        }
                    }
                }
            });
        }

        // Chart 5: Optimist vs Pessimist Balance
        function createOptimistPessimistBalance() {
            const ctx = createChartWrapper('optimistPessimistChart', 
                'Optimist vs Pessimist Evaluator Balance',
                'Single ring showing distribution by n (1-5) for optimist cases (left) and pessimist cases (right). Center shows total case counts.');
            
            // Count cases by score comparison
            let optimistCases = 0;
            let pessimistCases = 0;
            
            // Count by n value for each type
            const optimistByN = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
            const pessimistByN = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
            
            severityData.evaluations.forEach(evaluation => {
                // Determine case type by score
                if (evaluation.optimist.score > evaluation.pessimist.score) {
                    optimistCases++;
                    // Add to n distribution for optimists
                    const n = evaluation.optimist.n;
                    if (n >= 1 && n <= 5) optimistByN[n]++;
                } else if (evaluation.pessimist.score > evaluation.optimist.score) {
                    pessimistCases++;
                    // Add to n distribution for pessimists
                    const n = evaluation.pessimist.n;
                    if (n >= 1 && n <= 5) pessimistByN[n]++;
                }
            });

            // Create plugin to draw center text
            const centerTextPlugin = {
                id: 'centerText',
                beforeDraw: function(chart) {
                    const ctx = chart.ctx;
                    const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                    const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = '300 24px Inter';
                    ctx.fillStyle = '#e5e7eb';
                    ctx.fillText(optimistCases + ' | ' + pessimistCases, centerX, centerY - 10);
                    ctx.font = '300 12px Inter';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText('Optimist | Pessimist', centerX, centerY + 15);
                    ctx.restore();
                }
            };

            charts.optimistPessimistChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [
                        'Opt n=1', 'Opt n=2', 'Opt n=3', 'Opt n=4', 'Opt n=5',
                        'Pes n=1', 'Pes n=2', 'Pes n=3', 'Pes n=4', 'Pes n=5'
                    ],
                    datasets: [{
                        data: [
                            optimistByN[1], optimistByN[2], optimistByN[3], optimistByN[4], optimistByN[5],
                            pessimistByN[1], pessimistByN[2], pessimistByN[3], pessimistByN[4], pessimistByN[5]
                        ],
                        backgroundColor: [
                            // Optimist shades (blue gradient)
                            'rgba(59, 130, 246, 0.9)',
                            'rgba(59, 130, 246, 0.75)',
                            'rgba(59, 130, 246, 0.6)',
                            'rgba(59, 130, 246, 0.45)',
                            'rgba(59, 130, 246, 0.3)',
                            // Pessimist shades (red gradient)
                            'rgba(239, 68, 68, 0.9)',
                            'rgba(239, 68, 68, 0.75)',
                            'rgba(239, 68, 68, 0.6)',
                            'rgba(239, 68, 68, 0.45)',
                            'rgba(239, 68, 68, 0.3)'
                        ],
                        borderColor: '#1f2937',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                font: {
                                    size: 12
                                },
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 20,
                                usePointStyle: true
                            },
                            align: 'center',
                            fullSize: true,
                            maxHeight: 120
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                if (value === 0) return '';
                                return value;
                            },
                            color: '#ffffff',
                            font: {
                                size: 11,
                                weight: '300'
                            },
                            textAlign: 'center',
                            display: function(context) {
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    return label + ': ' + value + ' cases';
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, centerTextPlugin]
            });
        }

        // New Chart: Ridge Plot
        function createRidgePlot() {
            const ctx = createChartWrapper('ridgePlot', 
                'Ridge Plot: Semantic Score Distributions',
                'Overlapping density distributions of semantic scores grouped by GDX severity level. Higher ridges show more concentrated scores.');
            
            // Group semantic scores by GDX severity
            const scoresByGDXSeverity = {};
            for (let i = 3; i <= 10; i++) {
                scoresByGDXSeverity[`S${i}`] = [];
            }
            
            severityData.evaluations.forEach((sevEval) => {
                const semEval = semanticData.evaluations.find(s => s.case_id === sevEval.id);
                if (!semEval) return;
                
                const gdxSev = sevEval.gdx.severity;
                
                // Collect all semantic scores for this case
                const allScores = [];
                Object.values(semEval.ddx_semantic_scores).forEach(scores => {
                    allScores.push(...scores);
                });
                
                if (scoresByGDXSeverity[gdxSev]) {
                    scoresByGDXSeverity[gdxSev].push(...allScores);
                }
            });
            
            // Calculate KDE for each severity level
            const ridgeData = [];
            const severityLevels = Object.keys(scoresByGDXSeverity).reverse(); // Top to bottom
            
            severityLevels.forEach((severity, idx) => {
                const scores = scoresByGDXSeverity[severity];
                if (scores.length > 0) {
                    const kde = calculateKDE(scores, 0.05, 0, 1, 100);
                    const maxDensity = Math.max(...kde.map(d => d.y));
                    
                    // Normalize and offset for ridge effect
                    const normalizedKDE = kde.map(point => ({
                        x: point.x,
                        y: (point.y / maxDensity) * 0.8 + idx
                    }));
                    
                    ridgeData.push({
                        severity: severity,
                        kde: normalizedKDE,
                        baseline: idx,
                        color: `hsl(${260 - idx * 20}, 70%, 60%)` // Gradient from purple to orange
                    });
                }
            });
            
            // Custom plugin for ridge plot
            const ridgePlugin = {
                id: 'ridge',
                beforeDraw: (chart) => {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y;
                    
                    ridgeData.forEach((ridge, idx) => {
                        // Draw filled area
                        ctx.save();
                        ctx.beginPath();
                        
                        // Start from baseline
                        ctx.moveTo(
                            xScale.getPixelForValue(0),
                            yScale.getPixelForValue(ridge.baseline)
                        );
                        
                        // Draw KDE curve
                        ridge.kde.forEach(point => {
                            const x = xScale.getPixelForValue(point.x);
                            const y = yScale.getPixelForValue(point.y);
                            ctx.lineTo(x, y);
                        });
                        
                        // Close path at baseline
                        ctx.lineTo(
                            xScale.getPixelForValue(1),
                            yScale.getPixelForValue(ridge.baseline)
                        );
                        ctx.closePath();
                        
                        // Fill with gradient
                        const gradient = ctx.createLinearGradient(
                            0, yScale.getPixelForValue(ridge.baseline + 0.8),
                            0, yScale.getPixelForValue(ridge.baseline)
                        );
                        gradient.addColorStop(0, ridge.color);
                        gradient.addColorStop(1, ridge.color.replace('60%', '30%'));
                        
                        ctx.fillStyle = gradient;
                        ctx.globalAlpha = 0.7;
                        ctx.fill();
                        
                        // Draw outline
                        ctx.strokeStyle = ridge.color;
                        ctx.globalAlpha = 1;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Add severity label
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 12px Inter';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            ridge.severity,
                            chartArea.left - 10,
                            yScale.getPixelForValue(ridge.baseline + 0.4)
                        );
                        
                        ctx.restore();
                    });
                }
            };
            
            charts.ridgePlot = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 50,
                            right: 20
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false },
                        datalabels: { display: false }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Semantic Similarity Score',
                                color: '#ffffff'
                            },
                            min: 0,
                            max: 1,
                            ticks: { color: '#9ca3af' },
                            grid: { color: '#1f2937' }
                        },
                        y: {
                            type: 'linear',
                            display: false,
                            min: -0.5,
                            max: severityLevels.length - 0.5
                        }
                    }
                },
                plugins: [ridgePlugin]
            });
        }

        // Add tab switching functionality
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active to clicked tab
                    tab.classList.add('active');
                    // Show corresponding chart
                    showChart(tab.dataset.chart);
                });
            });
        }
        
        // Setup semantic sub-tabs
        function setupSemanticSubTabs() {
            const subtabs = document.querySelectorAll('.semantic-subtab');
            subtabs.forEach(subtab => {
                subtab.addEventListener('click', () => {
                    // Remove active from all semantic subtabs
                    subtabs.forEach(st => {
                        st.classList.remove('active');
                        st.style.color = '#6b7280';
                        st.style.borderBottomColor = 'transparent';
                    });
                    // Add active to clicked subtab
                    subtab.classList.add('active');
                    subtab.style.color = '#e5e7eb';
                    subtab.style.borderBottomColor = '#1e3a8a';
                    // Show corresponding subchart
                    showSemanticSubChart(subtab.dataset.subchart);
                });
                
                // Add hover effects
                subtab.addEventListener('mouseenter', () => {
                    if (!subtab.classList.contains('active')) {
                        subtab.style.color = '#ffffff';
                        subtab.style.background = '#1f2937';
                    }
                });
                subtab.addEventListener('mouseleave', () => {
                    if (!subtab.classList.contains('active')) {
                        subtab.style.color = '#6b7280';
                        subtab.style.background = 'transparent';
                    }
                });
            });
            
            // Set initial active state
            const activeSubtab = document.querySelector('.semantic-subtab.active');
            if (activeSubtab) {
                activeSubtab.style.color = '#e5e7eb';
                activeSubtab.style.borderBottomColor = '#1e3a8a';
            }
        }
        
        // Setup severity sub-tabs
        function setupSeveritySubTabs() {
            const subtabs = document.querySelectorAll('.severity-subtab');
            subtabs.forEach(subtab => {
                subtab.addEventListener('click', () => {
                    // Remove active from all severity subtabs
                    subtabs.forEach(st => {
                        st.classList.remove('active');
                        st.style.color = '#6b7280';
                        st.style.borderBottomColor = 'transparent';
                    });
                    // Add active to clicked subtab
                    subtab.classList.add('active');
                    subtab.style.color = '#e5e7eb';
                    subtab.style.borderBottomColor = '#1e3a8a';
                    // Show corresponding subchart
                    showSeveritySubChart(subtab.dataset.subchart);
                });
                
                // Add hover effects
                subtab.addEventListener('mouseenter', () => {
                    if (!subtab.classList.contains('active')) {
                        subtab.style.color = '#ffffff';
                        subtab.style.background = '#1f2937';
                    }
                });
                subtab.addEventListener('mouseleave', () => {
                    if (!subtab.classList.contains('active')) {
                        subtab.style.color = '#6b7280';
                        subtab.style.background = 'transparent';
                    }
                });
            });
            
            // Set initial active state
            const activeSubtab = document.querySelector('.severity-subtab.active');
            if (activeSubtab) {
                activeSubtab.style.color = '#e5e7eb';
                activeSubtab.style.borderBottomColor = '#1e3a8a';
            }
        }
        
        function showSemanticSubChart(subchartId) {
            // Hide all semantic subcharts
            const subcharts = document.querySelectorAll('.semantic-subchart');
            subcharts.forEach(sc => sc.style.display = 'none');
            
            // Show selected subchart
            const selectedSubchart = document.getElementById(subchartId + 'Section');
            if (selectedSubchart) {
                selectedSubchart.style.display = 'block';
            }
        }
        
        function showSeveritySubChart(subchartId) {
            // Hide all severity subcharts
            const subcharts = document.querySelectorAll('.severity-subchart');
            subcharts.forEach(sc => sc.style.display = 'none');
            
            // Show selected subchart
            const selectedSubchart = document.getElementById(subchartId + 'Section');
            if (selectedSubchart) {
                selectedSubchart.style.display = 'block';
            }
        }
        
        function showChart(chartId) {
            // Hide all charts
            const containers = document.querySelectorAll('.chart-container');
            containers.forEach(c => c.classList.remove('active'));
            
            // Show selected chart
            let selectedChart;
            if (chartId === 'statisticsSummary') {
                selectedChart = document.getElementById('statisticsSummary');
            } else if (chartId === 'semanticPlots') {
                selectedChart = document.getElementById('semanticPlotsContainer');
            } else if (chartId === 'severityPlots') {
                selectedChart = document.getElementById('severityPlotsContainer');
            } else {
                selectedChart = document.getElementById(chartId + 'Container');
            }
            
            if (selectedChart) {
                selectedChart.classList.add('active');
            }
        }

        // Download functions
        function downloadChart(chartId) {
            // Create modal for format selection
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: #0f0f0f;
                border: 1px solid #1f2937;
                border-radius: 8px;
                padding: 30px;
                min-width: 300px;
                text-align: center;
            `;
            
            modalContent.innerHTML = `
                <h3 style="color: #e5e7eb; font-weight: 300; margin-bottom: 20px;">Choose Download Format</h3>
                <button class="download-format-btn" data-format="transparent" style="
                    display: block;
                    width: 100%;
                    margin: 10px 0;
                    padding: 12px 20px;
                    background: transparent;
                    color: #9ca3af;
                    border: 1px solid #374151;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: all 0.3s ease;
                ">Transparent Background (Default)</button>
                <button class="download-format-btn" data-format="dark" style="
                    display: block;
                    width: 100%;
                    margin: 10px 0;
                    padding: 12px 20px;
                    background: transparent;
                    color: #9ca3af;
                    border: 1px solid #374151;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: all 0.3s ease;
                ">Dark Background</button>
                <button class="download-format-btn" data-format="light" style="
                    display: block;
                    width: 100%;
                    margin: 10px 0;
                    padding: 12px 20px;
                    background: transparent;
                    color: #9ca3af;
                    border: 1px solid #374151;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: all 0.3s ease;
                ">Light Background</button>
                <button onclick="this.closest('div').parentElement.remove()" style="
                    margin-top: 20px;
                    padding: 8px 16px;
                    background: transparent;
                    color: #6b7280;
                    border: 1px solid #374151;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 12px;
                    transition: all 0.3s ease;
                ">Cancel</button>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add hover effect
            modalContent.querySelectorAll('.download-format-btn').forEach(btn => {
                btn.onmouseover = function() {
                    this.style.background = '#111111';
                    this.style.color = '#e5e7eb';
                    this.style.borderColor = '#4b5563';
                };
                btn.onmouseout = function() {
                    this.style.background = 'transparent';
                    this.style.color = '#9ca3af';
                    this.style.borderColor = '#374151';
                };
                
                btn.onclick = function() {
                    const format = this.dataset.format;
                    downloadChartWithFormat(chartId, format);
                    modal.remove();
                };
            });
            
            // Close modal on outside click
            modal.onclick = function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        function downloadChartWithFormat(chartId, format) {
            const chart = charts[chartId];
            if (!chart) return;
            
            // Store original colors
            const originalLegendColor = chart.options.plugins.legend.labels.color;
            const originalTitleColors = {};
            const originalTickColors = {};
            
            // Update colors based on format
            if (format === 'light') {
                // Dark text for light background
                chart.options.plugins.legend.labels.color = '#000000';
                
                // Update axis colors
                Object.keys(chart.options.scales).forEach(axis => {
                    if (chart.options.scales[axis].title) {
                        originalTitleColors[axis] = chart.options.scales[axis].title.color;
                        chart.options.scales[axis].title.color = '#000000';
                    }
                    if (chart.options.scales[axis].ticks) {
                        originalTickColors[axis] = chart.options.scales[axis].ticks.color;
                        chart.options.scales[axis].ticks.color = '#000000';
                    }
                });
            }
            
            // Update chart
            chart.update('none');
            
            // Create download canvas
            const canvas = document.getElementById(chartId);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill background based on format
            if (format === 'dark') {
                tempCtx.fillStyle = '#050505';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            } else if (format === 'light') {
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            }
            // For transparent, we don't fill anything
            
            // Draw the chart on top
            tempCtx.drawImage(canvas, 0, 0);
            
            // Restore original colors
            if (format === 'light') {
                chart.options.plugins.legend.labels.color = originalLegendColor;
                
                Object.keys(chart.options.scales).forEach(axis => {
                    if (originalTitleColors[axis]) {
                        chart.options.scales[axis].title.color = originalTitleColors[axis];
                    }
                    if (originalTickColors[axis]) {
                        chart.options.scales[axis].ticks.color = originalTickColors[axis];
                    }
                });
                
                chart.update('none');
            }
            
            // Download
            const url = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `${chartId}_${format}.png`;
            link.href = url;
            link.click();
        }

        function downloadAllCharts() {
            Object.keys(charts).forEach(chartId => {
                setTimeout(() => downloadChart(chartId), 100);
            });
        }
    </script>
</body>
</html>